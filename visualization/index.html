<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Italian-American Literary Network</title>

  <!-- Libraries -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/graphology@0.24.1/dist/graphology.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ngraph.graph@19.1.0/dist/ngraph.graph.min.js"></script>
  <script src="https://unpkg.com/ngraph.path@1.3.1/dist/ngraph.path.min.js"></script>
  <script src="https://unpkg.com/canvg@3.0.7/lib/umd.js"></script>

  <!-- Typography -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400&family=Source+Sans+3:wght@300;400;500;600&display=swap" rel="stylesheet">

  <style>
    /* ═══════════════════════════════════════════════════════════════
       ARCHIVAL LITERARY AESTHETIC
       Inspired by manuscript archives, scholarly libraries, and
       the transatlantic correspondence of mid-century literati
    ═══════════════════════════════════════════════════════════════ */

    :root {
      /* Manuscript palette */
      --parchment: #f7f4ed;
      --parchment-dark: #ebe6da;
      --ink-dark: #1a1a1a;
      --ink-medium: #3d3d3d;
      --ink-light: #6b6b6b;
      --sepia: #8b7355;
      --sepia-light: #a08a6e;
      --sepia-dark: #6d5a44;
      --accent-blue: #4a6670;
      --accent-blue-light: #6b8e9f;
      --rust: #8b5a3c;
      --gold: #c4a35a;
      --shadow: rgba(26, 26, 26, 0.08);
      --shadow-deep: rgba(26, 26, 26, 0.15);

      /* Institution subtype palette - warm scholarly tones */
      --subtype-magazine: #b8860b;     /* Dark goldenrod - periodicals */
      --subtype-publisher: #8b7355;    /* Original sepia - books */
      --subtype-university: #5d6d7e;   /* Slate blue-gray - academia */
      --subtype-organization: #9a7b4f; /* Warm bronze - cultural orgs */
      --subtype-media: #a67c52;        /* Warm copper - broadcast */
      --subtype-business: #7a6e5d;     /* Neutral brown-gray */
      --subtype-event: #946b4a;        /* Terracotta - gatherings */
      --subtype-government: #5a5d5e;   /* Institutional gray */
      --subtype-other: #8a8070;        /* Muted neutral */

      /* Typography */
      --font-display: 'Cormorant Garamond', Georgia, 'Times New Roman', serif;
      --font-body: 'Source Sans 3', -apple-system, BlinkMacSystemFont, sans-serif;

      /* Spacing */
      --sidebar-width: 300px;
      --header-height: 56px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-body);
      background: var(--parchment);
      color: var(--ink-medium);
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      line-height: 1.5;
    }

    /* ═══════════════════════════════════════════════════════════════
       HEADER
    ═══════════════════════════════════════════════════════════════ */

    #header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: var(--header-height);
      background: linear-gradient(180deg, var(--ink-dark) 0%, #2a2a2a 100%);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 24px;
      z-index: 1000;
      border-bottom: 1px solid var(--sepia-dark);
    }

    .header-title {
      font-family: var(--font-display);
      font-size: 1.5rem;
      font-weight: 500;
      color: var(--parchment);
      letter-spacing: 0.02em;
    }

    .header-title span {
      font-style: italic;
      font-weight: 400;
      opacity: 0.8;
    }

    .header-actions {
      display: flex;
      gap: 12px;
    }

    .header-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      background: transparent;
      border: 1px solid rgba(247, 244, 237, 0.2);
      border-radius: 4px;
      color: var(--parchment);
      font-family: var(--font-body);
      font-size: 0.8rem;
      font-weight: 500;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .header-btn:hover {
      background: rgba(247, 244, 237, 0.1);
      border-color: rgba(247, 244, 237, 0.3);
    }

    .header-btn svg {
      width: 14px;
      height: 14px;
      opacity: 0.8;
    }

    /* ═══════════════════════════════════════════════════════════════
       SIDEBAR
    ═══════════════════════════════════════════════════════════════ */

    #sidebar {
      position: fixed;
      left: 0;
      top: var(--header-height);
      width: var(--sidebar-width);
      height: calc(100vh - var(--header-height));
      background: var(--parchment);
      border-right: 1px solid var(--parchment-dark);
      overflow-y: auto;
      z-index: 900;
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 2px 0 12px var(--shadow);
    }

    #sidebar.hidden {
      transform: translateX(-100%);
    }

    #sidebar-backdrop {
      display: none;
    }

    #sidebar::-webkit-scrollbar {
      width: 4px;
    }

    #sidebar::-webkit-scrollbar-track {
      background: transparent;
    }

    #sidebar::-webkit-scrollbar-thumb {
      background: var(--sepia-light);
      border-radius: 2px;
    }

    .sidebar-section {
      padding: 20px;
      border-bottom: 1px solid var(--parchment-dark);
    }

    .sidebar-section:last-child {
      border-bottom: none;
    }

    .section-label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-family: var(--font-display);
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--sepia);
      margin-bottom: 12px;
    }

    .section-label svg {
      width: 14px;
      height: 14px;
      opacity: 0.7;
    }

    .section-title {
      font-family: var(--font-display);
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--ink-dark);
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .help-tip {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      background: var(--sepia);
      color: var(--parchment);
      border-radius: 50%;
      font-size: 10px;
      font-weight: 600;
      cursor: help;
      position: relative;
    }

    .help-tip::after {
      content: attr(data-tip);
      position: absolute;
      left: 50%;
      top: calc(100% + 8px);
      transform: translateX(-50%);
      background: var(--ink-dark);
      color: var(--parchment);
      padding: 10px 14px;
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 400;
      line-height: 1.5;
      width: max-content;
      max-width: 220px;
      text-align: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 100;
      box-shadow: 0 4px 16px var(--shadow-deep);
    }

    .help-tip:hover::after {
      opacity: 1;
    }

    /* Input styles */
    .input-field {
      width: 100%;
      padding: 10px 12px;
      background: #fff;
      border: 1px solid var(--parchment-dark);
      border-radius: 4px;
      font-family: var(--font-body);
      font-size: 0.875rem;
      color: var(--ink-dark);
      transition: all 0.2s ease;
      margin-bottom: 8px;
    }

    .input-field:focus {
      outline: none;
      border-color: var(--sepia);
      box-shadow: 0 0 0 3px rgba(139, 115, 85, 0.1);
    }

    .input-field::placeholder {
      color: var(--ink-light);
    }

    /* Button styles */
    .btn {
      width: 100%;
      padding: 10px 16px;
      background: var(--parchment);
      border: 1px solid var(--sepia);
      border-radius: 4px;
      font-family: var(--font-body);
      font-size: 0.8rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      color: var(--sepia-dark);
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 6px;
    }

    .btn:hover {
      background: var(--sepia);
      color: var(--parchment);
    }

    .btn:active {
      transform: translateY(1px);
    }

    .btn-row {
      display: flex;
      gap: 8px;
    }

    .btn-row .btn {
      flex: 1;
    }

    /* Slider */
    .slider-wrap {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .slider-wrap input[type="range"] {
      flex: 1;
      -webkit-appearance: none;
      height: 4px;
      background: var(--parchment-dark);
      border-radius: 2px;
      outline: none;
    }

    .slider-wrap input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: var(--sepia);
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .slider-wrap input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .slider-value {
      min-width: 32px;
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--sepia-dark);
      text-align: right;
    }

    /* Path info display */
    #path-info {
      display: none;
      margin-top: 12px;
      padding: 12px;
      background: rgba(139, 115, 85, 0.08);
      border-left: 3px solid var(--sepia);
      border-radius: 0 4px 4px 0;
      font-size: 0.8rem;
      color: var(--ink-medium);
      line-height: 1.5;
    }

    /* Legend */
    .legend-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
      color: var(--ink-medium);
    }

    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .legend-line {
      width: 20px;
      height: 3px;
      border-radius: 1px;
      flex-shrink: 0;
    }

    .legend-dot.person { background: var(--accent-blue-light); }
    .legend-dot.institution { background: var(--sepia); }

    /* ═══════════════════════════════════════════════════════════════
       FILTER PILLS - Interactive type filtering
    ═══════════════════════════════════════════════════════════════ */

    .filter-pills {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 0.5rem;
    }

    .filter-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 20px;
      font-size: 0.72rem;
      font-family: var(--font-body);
      letter-spacing: 0.02em;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 1.5px solid transparent;
      background: var(--parchment);
      color: var(--ink-medium);
      user-select: none;
    }

    .filter-pill:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .filter-pill.active {
      border-color: currentColor;
      font-weight: 600;
    }

    .filter-pill.dimmed {
      opacity: 0.4;
    }

    .filter-pill .pill-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .filter-pill-divider {
      width: 100%;
      height: 1px;
      background: var(--parchment-dark);
      margin: 4px 0;
    }

    .filter-mode-toggle {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      margin: 12px auto 0 auto;
      padding: 12px 16px;
      background: rgba(255,255,255,0.6);
      border-radius: 8px;
      border: 1px solid var(--parchment-dark);
      max-width: 200px;
    }

    .filter-mode-label {
      font-size: 0.72rem;
      font-weight: 500;
      color: var(--ink-medium);
      text-align: center;
    }

    .filter-mode-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      width: 100%;
    }

    .filter-mode-btn {
      padding: 8px 12px;
      border: 1.5px solid var(--parchment-dark);
      background: var(--parchment);
      cursor: pointer;
      font-size: 0.75rem;
      font-family: var(--font-body);
      font-weight: 500;
      transition: all 0.2s ease;
      text-align: center;
    }

    .filter-mode-btn:first-child {
      border-radius: 6px 0 0 6px;
      border-right-width: 0.75px;
    }

    .filter-mode-btn:last-child {
      border-radius: 0 6px 6px 0;
      border-left-width: 0.75px;
    }

    .filter-mode-btn:hover {
      background: var(--parchment-dark);
      border-color: var(--sepia-light);
    }

    .filter-mode-btn.active {
      background: var(--sepia);
      color: var(--parchment);
      border-color: var(--sepia);
      font-weight: 600;
    }

    .filter-section-label {
      width: 100%;
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--ink-light);
      margin: 6px 0 2px 0;
      font-family: var(--font-body);
    }

    .filter-count {
      font-size: 0.7rem;
      color: var(--ink-light);
      font-style: italic;
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid var(--parchment-dark);
    }

    /* Community toggle */
    .btn.active {
      background: var(--sepia);
      color: var(--parchment);
    }

    #community-info {
      margin-top: 8px;
      font-size: 0.78rem;
      color: var(--ink-light);
    }

    /* 2-hop button in details panel */
    .details-expand-btn {
      display: block;
      width: 100%;
      margin-top: 10px;
      padding: 7px 12px;
      background: var(--parchment);
      border: 1px solid var(--sepia);
      border-radius: 4px;
      font-family: var(--font-body);
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--sepia-dark);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .details-expand-btn:hover {
      background: var(--sepia);
      color: var(--parchment);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    /* Toggle button (in header) */
    #toggle-sidebar {
      width: 36px;
      height: 36px;
      background: transparent;
      border: 1px solid rgba(247, 244, 237, 0.2);
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    #toggle-sidebar:hover {
      background: rgba(247, 244, 237, 0.1);
      border-color: rgba(247, 244, 237, 0.3);
    }

    #toggle-sidebar svg {
      width: 18px;
      height: 18px;
      stroke: var(--parchment);
      stroke-width: 2;
      fill: none;
    }

    /* ═══════════════════════════════════════════════════════════════
       AUTOCOMPLETE
    ═══════════════════════════════════════════════════════════════ */

    .autocomplete {
      position: relative;
    }

    .autocomplete-items {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #fff;
      border: 1px solid var(--parchment-dark);
      border-top: none;
      border-radius: 0 0 4px 4px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      box-shadow: 0 4px 12px var(--shadow);
    }

    .autocomplete-items div {
      padding: 8px 12px;
      font-size: 0.875rem;
      cursor: pointer;
      border-bottom: 1px solid var(--parchment-dark);
      transition: background 0.15s ease;
    }

    .autocomplete-items div:last-child {
      border-bottom: none;
    }

    .autocomplete-items div:hover,
    .autocomplete-active {
      background: var(--parchment-dark);
    }

    .autocomplete-items div strong {
      color: var(--sepia);
    }

    /* ═══════════════════════════════════════════════════════════════
       CANVAS & VISUALIZATION
    ═══════════════════════════════════════════════════════════════ */

    #canvas {
      position: fixed;
      top: var(--header-height);
      left: var(--sidebar-width);
      width: calc(100vw - var(--sidebar-width));
      height: calc(100vh - var(--header-height));
      background: transparent;
      transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1), width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 2;
    }

    #sidebar.hidden ~ #canvas {
      left: 0;
      width: 100vw;
    }

    #link-canvas {
      position: fixed;
      top: var(--header-height);
      left: var(--sidebar-width);
      width: calc(100vw - var(--sidebar-width));
      height: calc(100vh - var(--header-height));
      pointer-events: none;
      z-index: 1;
      background:
        radial-gradient(ellipse at center, var(--parchment) 0%, var(--parchment-dark) 100%);
      transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1), width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #sidebar.hidden ~ #link-canvas {
      left: 0;
      width: 100vw;
    }

    .tooltip {
      position: absolute;
      padding: 10px 14px;
      background: var(--ink-dark);
      color: var(--parchment);
      border-radius: 4px;
      font-family: var(--font-body);
      font-size: 0.8rem;
      pointer-events: none;
      z-index: 1100;
      box-shadow: 0 4px 12px var(--shadow-deep);
      max-width: 280px;
    }

    .label {
      font-family: var(--font-display);
      font-size: 12px;
      font-weight: 500;
      fill: var(--ink-medium);
      pointer-events: none;
      text-shadow:
        -1px -1px 0 var(--parchment),
        1px -1px 0 var(--parchment),
        -1px 1px 0 var(--parchment),
        1px 1px 0 var(--parchment),
        0 0 8px var(--parchment);
    }

    .highlight-node {
      stroke: var(--gold) !important;
      stroke-width: 3px !important;
    }

    /* ═══════════════════════════════════════════════════════════════
       LOADING OVERLAY
    ═══════════════════════════════════════════════════════════════ */

    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--parchment);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      transition: opacity 0.5s ease;
    }

    #loading-overlay.fade-out {
      opacity: 0;
      pointer-events: none;
    }

    .loading-content {
      text-align: center;
    }

    .loading-title {
      font-family: var(--font-display);
      font-size: 1.5rem;
      font-weight: 500;
      color: var(--ink-dark);
      margin-bottom: 24px;
      font-style: italic;
    }

    .loading-bar {
      width: 200px;
      height: 3px;
      background: var(--parchment-dark);
      border-radius: 2px;
      overflow: hidden;
      margin-bottom: 16px;
    }

    #progress-bar {
      height: 100%;
      background: var(--sepia);
      width: 0%;
      transition: width 0.3s ease;
    }

    .loading-status {
      font-size: 0.8rem;
      color: var(--ink-light);
    }

    /* ═══════════════════════════════════════════════════════════════
       MODAL
    ═══════════════════════════════════════════════════════════════ */

    .modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .modal.show {
      display: flex;
    }

    .modal-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(26, 26, 26, 0.6);
      backdrop-filter: blur(4px);
    }

    .modal-content {
      position: relative;
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      background: var(--parchment);
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 24px 48px rgba(26, 26, 26, 0.3);
      animation: modalIn 0.3s ease;
    }

    @keyframes modalIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .modal.closing .modal-content {
      animation: modalOut 0.3s ease forwards;
    }

    @keyframes modalOut {
      to {
        opacity: 0;
        transform: translateY(20px);
      }
    }

    .modal-header {
      padding: 24px 24px 16px;
      border-bottom: 1px solid var(--parchment-dark);
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
    }

    .modal-title {
      font-family: var(--font-display);
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--ink-dark);
    }

    .modal-close {
      width: 32px;
      height: 32px;
      background: transparent;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: background 0.2s ease;
    }

    .modal-close:hover {
      background: var(--parchment-dark);
    }

    .modal-close svg {
      width: 20px;
      height: 20px;
      stroke: var(--ink-medium);
      stroke-width: 2;
    }

    .modal-body {
      padding: 24px;
      overflow-y: auto;
      max-height: 50vh;
    }

    .modal-body p {
      margin-bottom: 16px;
      font-size: 0.95rem;
      line-height: 1.7;
      color: var(--ink-medium);
    }

    .modal-body p:last-child {
      margin-bottom: 0;
    }

    .modal-body a {
      color: var(--sepia);
      text-decoration: underline;
      text-underline-offset: 2px;
    }

    .modal-body a:hover {
      color: var(--sepia-dark);
    }

    .modal-footer {
      padding: 16px 24px 24px;
      display: flex;
      justify-content: flex-end;
    }

    .modal-footer .btn {
      width: auto;
      padding: 10px 24px;
    }

    /* ═══════════════════════════════════════════════════════════════
       FOOTER
    ═══════════════════════════════════════════════════════════════ */

    footer {
      position: fixed;
      bottom: 0;
      right: 0;
      padding: 8px 16px;
      font-size: 0.75rem;
      color: var(--ink-light);
      z-index: 100;
    }

    footer a {
      color: var(--ink-light);
      text-decoration: none;
      transition: color 0.2s ease;
    }

    footer a:hover {
      color: var(--sepia);
    }

    /* ═══════════════════════════════════════════════════════════════
       EXPLORER CHIPS
    ═══════════════════════════════════════════════════════════════ */

    .explorer-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 8px;
      min-height: 0;
    }

    .explorer-chips:empty {
      display: none;
    }

    .explorer-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 8px;
      background: var(--parchment-dark);
      border: 1px solid rgba(139, 115, 85, 0.25);
      border-radius: 3px;
      font-size: 0.72rem;
      color: var(--ink-medium);
      max-width: 100%;
      animation: chipIn 0.2s ease-out;
    }

    @keyframes chipIn {
      from { opacity: 0; transform: scale(0.85); }
      to { opacity: 1; transform: scale(1); }
    }

    .explorer-chip-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 180px;
    }

    .explorer-chip-remove {
      width: 14px;
      height: 14px;
      border: none;
      background: transparent;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      padding: 0;
      opacity: 0.5;
      transition: opacity 0.15s;
      flex-shrink: 0;
    }

    .explorer-chip-remove:hover {
      opacity: 1;
      background: rgba(139, 90, 60, 0.15);
    }

    .explorer-chip-remove svg {
      width: 10px;
      height: 10px;
      stroke: var(--ink-medium);
      stroke-width: 2.5;
    }

    .explorer-result-count {
      font-size: 0.78rem;
      color: var(--sepia);
      font-style: italic;
      margin-top: 6px;
      padding: 0 2px;
    }

    /* ═══════════════════════════════════════════════════════════════
       NODE DETAILS PANEL
    ═══════════════════════════════════════════════════════════════ */

    #node-details {
      position: fixed;
      right: 0;
      top: var(--header-height);
      width: 320px;
      height: calc(100vh - var(--header-height));
      background: var(--parchment);
      border-left: 1px solid var(--parchment-dark);
      box-shadow: -4px 0 24px var(--shadow-deep);
      z-index: 950;
      transform: translateX(100%);
      transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #node-details.open {
      transform: translateX(0);
    }

    .details-header {
      padding: 24px 20px 16px;
      border-bottom: 1px solid var(--parchment-dark);
      position: relative;
      flex-shrink: 0;
    }

    .details-close {
      position: absolute;
      top: 16px;
      right: 16px;
      width: 28px;
      height: 28px;
      background: transparent;
      border: 1px solid var(--parchment-dark);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .details-close:hover {
      background: var(--parchment-dark);
      border-color: var(--sepia-light);
    }

    .details-close svg {
      width: 14px;
      height: 14px;
      stroke: var(--ink-medium);
      stroke-width: 2;
    }

    .details-node-name {
      font-family: var(--font-display);
      font-size: 1.35rem;
      font-weight: 600;
      color: var(--ink-dark);
      line-height: 1.3;
      padding-right: 36px;
      margin-bottom: 8px;
    }

    .details-meta {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .details-type-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 3px;
      font-size: 0.7rem;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .details-type-badge.person {
      background: rgba(107, 142, 159, 0.12);
      color: var(--accent-blue);
    }

    .details-type-badge.institution {
      background: rgba(139, 115, 85, 0.12);
      color: var(--sepia-dark);
    }

    .details-type-badge::before {
      content: '';
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }

    .details-type-badge.person::before {
      background: var(--accent-blue-light);
    }

    .details-type-badge.institution::before {
      background: var(--sepia);
    }

    .details-degree {
      font-size: 0.8rem;
      color: var(--ink-light);
      font-style: italic;
    }

    .details-connections {
      flex: 1;
      overflow-y: auto;
      padding: 0;
    }

    .details-connections::-webkit-scrollbar {
      width: 4px;
    }

    .details-connections::-webkit-scrollbar-track {
      background: transparent;
    }

    .details-connections::-webkit-scrollbar-thumb {
      background: var(--sepia-light);
      border-radius: 2px;
    }

    .details-section-heading {
      position: sticky;
      top: 0;
      padding: 12px 20px 8px;
      font-family: var(--font-display);
      font-size: 0.7rem;
      font-weight: 600;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--sepia);
      background: linear-gradient(180deg, var(--parchment) 70%, transparent);
      z-index: 1;
    }

    .details-connection-item {
      padding: 8px 20px;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      transition: background 0.15s ease;
      border-bottom: 1px solid rgba(235, 230, 218, 0.5);
    }

    .details-connection-item:hover {
      background: var(--parchment-dark);
    }

    .details-connection-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .details-connection-dot.person {
      background: var(--accent-blue-light);
    }

    .details-connection-dot.institution {
      background: var(--sepia);
    }

    .details-connection-name {
      font-size: 0.85rem;
      color: var(--ink-medium);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .details-connection-item:hover .details-connection-name {
      color: var(--ink-dark);
    }

    .details-empty {
      padding: 24px 20px;
      text-align: center;
      font-size: 0.85rem;
      color: var(--ink-light);
      font-style: italic;
    }

    /* ═══════════════════════════════════════════════════════════════
       RESPONSIVE — MOBILE
    ═══════════════════════════════════════════════════════════════ */

    @media (max-width: 768px) {
      :root {
        --sidebar-width: 85vw;
        --header-height: 50px;
      }

      /* Header: compact for mobile */
      #header {
        padding: 0 12px;
      }

      .header-title {
        font-size: 1.15rem;
      }

      .header-title span {
        display: none;
      }

      .header-actions {
        gap: 8px;
      }

      .header-btn {
        padding: 8px 10px;
        font-size: 0.7rem;
      }

      .header-btn span {
        display: none;
      }

      #toggle-sidebar {
        width: 44px;
        height: 44px;
      }

      /* Sidebar: slide-in overlay with backdrop */
      #sidebar {
        width: var(--sidebar-width);
        max-width: 320px;
        transform: translateX(-100%);
        box-shadow: 4px 0 24px rgba(26, 26, 26, 0.3);
      }

      #sidebar:not(.hidden) {
        transform: translateX(0);
      }

      /* Sidebar backdrop overlay */
      #sidebar-backdrop {
        display: none;
        position: fixed;
        top: var(--header-height);
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(26, 26, 26, 0.4);
        z-index: 899;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      #sidebar-backdrop.visible {
        display: block;
        opacity: 1;
      }

      .sidebar-section {
        padding: 16px;
      }

      /* Canvas & link-canvas: always full width on mobile */
      #canvas,
      #link-canvas {
        left: 0 !important;
        width: 100vw !important;
      }

      /* Touch-friendly inputs */
      .input-field {
        padding: 12px 14px;
        font-size: 16px; /* Prevents iOS zoom on focus */
        margin-bottom: 10px;
      }

      /* Touch-friendly buttons */
      .btn {
        padding: 12px 16px;
        font-size: 0.85rem;
        min-height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .btn-row {
        gap: 6px;
      }

      /* Touch-friendly slider */
      .slider-wrap input[type="range"] {
        height: 8px;
      }

      .slider-wrap input[type="range"]::-webkit-slider-thumb {
        width: 28px;
        height: 28px;
      }

      /* Touch-friendly autocomplete */
      .autocomplete-items div {
        padding: 12px 14px;
        font-size: 0.95rem;
        min-height: 44px;
        display: flex;
        align-items: center;
      }

      /* Node details panel: full width on mobile */
      #node-details {
        width: 100%;
      }

      .details-header {
        padding: 16px;
      }

      .details-connection-item {
        padding: 12px 16px;
        min-height: 44px;
      }

      .details-expand-btn {
        min-height: 44px;
        padding: 10px 12px;
        font-size: 0.85rem;
      }

      /* Modal: better mobile sizing */
      .modal-content {
        width: 95%;
        max-height: 85vh;
        margin: 0 auto;
      }

      .modal-body {
        max-height: 60vh;
        padding: 16px;
      }

      .modal-header {
        padding: 16px;
      }

      .modal-close {
        width: 44px;
        height: 44px;
      }

      /* Footer: smaller on mobile */
      footer {
        font-size: 0.65rem;
        padding: 6px 10px;
      }

      /* Explorer chips */
      .explorer-chip {
        padding: 6px 10px;
        font-size: 0.78rem;
      }

      .explorer-chip-remove {
        width: 22px;
        height: 22px;
      }

      /* Legend: single column on mobile */
      .legend-grid {
        grid-template-columns: 1fr;
        gap: 6px;
      }

      /* Community info */
      #community-info {
        font-size: 0.72rem;
      }

      /* Help tips: below instead of right */
      .help-tip::after {
        left: 50%;
        top: calc(100% + 8px);
        transform: translateX(-50%);
      }
    }

    /* Small phone screens */
    @media (max-width: 380px) {
      :root {
        --sidebar-width: 100vw;
      }

      #sidebar {
        max-width: none;
      }

      .header-title {
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <!-- Loading Overlay -->
  <div id="loading-overlay">
    <div class="loading-content">
      <div class="loading-title">Mapping Literary Networks...</div>
      <div class="loading-bar">
        <div id="progress-bar"></div>
      </div>
      <div class="loading-status">Initializing...</div>
    </div>
  </div>

  <!-- Header -->
  <header id="header">
    <div class="header-left">
      <button id="toggle-sidebar" onclick="toggleSidebar()" aria-label="Toggle sidebar">
        <svg viewBox="0 0 24 24">
          <line x1="3" y1="6" x2="21" y2="6"/>
          <line x1="3" y1="12" x2="21" y2="12"/>
          <line x1="3" y1="18" x2="21" y2="18"/>
        </svg>
      </button>
      <h1 class="header-title">Italian-American Literary Network <span>1890-1980</span></h1>
    </div>
    <div class="header-actions">
      <button class="header-btn" onclick="openAboutModal()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
          <circle cx="12" cy="12" r="10"/>
          <path d="M12 16v-4M12 8h.01"/>
        </svg>
        About
      </button>
    </div>
  </header>

  <!-- Sidebar backdrop (mobile) -->
  <div id="sidebar-backdrop" onclick="toggleSidebar()"></div>

  <!-- Sidebar -->
  <aside id="sidebar">
    <!-- Search -->
    <div class="sidebar-section">
      <div class="section-label">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"/>
          <path d="m21 21-4.35-4.35"/>
        </svg>
        Search
      </div>
      <div class="autocomplete">
        <input type="text" id="search" class="input-field" placeholder="Find individuals or institutions...">
      </div>
    </div>

    <!-- Connection Explorer -->
    <div class="sidebar-section">
      <div class="section-title">
        Connection Explorer
        <span class="help-tip" data-tip="2 nodes: trace paths. 3+ nodes: find shared connections.">?</span>
      </div>
      <div id="explorer-chips" class="explorer-chips"></div>
      <div class="autocomplete">
        <input type="text" id="explorer-input" class="input-field" placeholder="Add a node...">
      </div>
      <div class="btn-row">
        <button class="btn" onclick="NetworkViz.exploreConnections()">Find</button>
        <button class="btn" onclick="NetworkViz.clearPath()">Clear</button>
      </div>
      <div id="path-info"></div>
    </div>

    <!-- Density Filter -->
    <div class="sidebar-section">
      <div class="section-title">
        Network Density
        <span class="help-tip" data-tip="Show only nodes with the specified minimum number of connections">?</span>
      </div>
      <div class="slider-wrap">
        <input type="range" id="degree-range" min="0" max="5" value="0">
        <span id="degree-label" class="slider-value">1+</span>
      </div>
    </div>

    <!-- Type Filter Pills -->
    <div class="sidebar-section">
      <div class="section-title">
        Filter by Type
        <span class="help-tip" data-tip="Click to show only that type. Click again to reset.">?</span>
      </div>
      <div class="filter-pills" id="type-pills">
        <span class="filter-section-label">Node Types</span>
        <button class="filter-pill active" data-filter="all" onclick="NetworkViz.filterByType('all')">
          <span class="pill-dot" style="background: linear-gradient(135deg, #6b8e9f 50%, #8b7355 50%);"></span>
          All
        </button>
        <button class="filter-pill" data-filter="person" onclick="NetworkViz.filterByType('person')">
          <span class="pill-dot" style="background: #6b8e9f;"></span>
          Person
        </button>
        <button class="filter-pill" data-filter="institution" onclick="NetworkViz.filterByType('institution')">
          <span class="pill-dot" style="background: #8b7355;"></span>
          Institution
        </button>

        <span class="filter-section-label" id="subtype-label" style="display: none;">Institution Subtypes</span>
        <div class="filter-pills" id="subtype-pills" style="display: none;">
          <button class="filter-pill" data-subtype="magazine" onclick="NetworkViz.filterBySubtype('magazine')">
            <span class="pill-dot" style="background: #b8860b;"></span>
            Magazine
          </button>
          <button class="filter-pill" data-subtype="publisher" onclick="NetworkViz.filterBySubtype('publisher')">
            <span class="pill-dot" style="background: #8b7355;"></span>
            Publisher
          </button>
          <button class="filter-pill" data-subtype="university" onclick="NetworkViz.filterBySubtype('university')">
            <span class="pill-dot" style="background: #5d6d7e;"></span>
            University
          </button>
          <button class="filter-pill" data-subtype="organization" onclick="NetworkViz.filterBySubtype('organization')">
            <span class="pill-dot" style="background: #9a7b4f;"></span>
            Organization
          </button>
          <button class="filter-pill" data-subtype="media" onclick="NetworkViz.filterBySubtype('media')">
            <span class="pill-dot" style="background: #a67c52;"></span>
            Media
          </button>
          <button class="filter-pill" data-subtype="business" onclick="NetworkViz.filterBySubtype('business')">
            <span class="pill-dot" style="background: #7a6e5d;"></span>
            Business
          </button>
          <button class="filter-pill" data-subtype="event" onclick="NetworkViz.filterBySubtype('event')">
            <span class="pill-dot" style="background: #946b4a;"></span>
            Event
          </button>
          <button class="filter-pill" data-subtype="government" onclick="NetworkViz.filterBySubtype('government')">
            <span class="pill-dot" style="background: #5a5d5e;"></span>
            Government
          </button>
          <button class="filter-pill" data-subtype="uncategorized" onclick="NetworkViz.filterBySubtype('uncategorized')">
            <span class="pill-dot" style="background: #999;"></span>
            Other
          </button>
        </div>
        <div class="filter-mode-toggle" id="filter-mode-toggle">
          <div class="filter-mode-label">Show persons connected to:</div>
          <div class="filter-mode-buttons">
            <button class="filter-mode-btn active" data-mode="or" onclick="NetworkViz.setFilterMode('or')">Any</button>
            <button class="filter-mode-btn" data-mode="and" onclick="NetworkViz.setFilterMode('and')">All selected</button>
          </div>
        </div>
      </div>
      <div class="filter-count" id="filter-count"></div>
    </div>

    <!-- Communities -->
    <div class="sidebar-section">
      <div class="section-title">
        Communities
        <span class="help-tip" data-tip="Detect clusters using label propagation and color nodes by community">?</span>
      </div>
      <button class="btn" id="community-toggle" onclick="NetworkViz.toggleCommunities()">Color by Community</button>
      <div id="community-info" style="display:none"></div>
    </div>

    <!-- Actions -->
    <div class="sidebar-section">
      <button class="btn" onclick="NetworkViz.exportPNG()">Download Image</button>
      <button class="btn" id="export-subgraph-btn" style="display:none" onclick="NetworkViz.exportSubgraph()">Export Visible Subgraph</button>
      <button class="btn" onclick="NetworkViz.fullReset()">Reset View</button>
    </div>

    <!-- Edge Legend -->
    <div class="sidebar-section">
      <div class="section-label">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M5 12h14M12 5l7 7-7 7"/>
        </svg>
        Edge Types
      </div>
      <div class="legend-grid">
        <div class="legend-item">
          <span class="legend-line affiliation"></span>
          Affiliation
        </div>
        <div class="legend-item">
          <span class="legend-line personal"></span>
          Personal
        </div>
      </div>
    </div>
  </aside>

  <!-- Link Canvas (behind SVG for performance) -->
  <canvas id="link-canvas"></canvas>
  <!-- SVG Canvas (nodes and labels only) -->
  <svg id="canvas"></svg>

  <!-- Node Details Panel -->
  <aside id="node-details">
    <div class="details-header">
      <button class="details-close" onclick="closeNodeDetails()" aria-label="Close details">
        <svg viewBox="0 0 24 24" fill="none">
          <path d="M18 6L6 18M6 6l12 12"/>
        </svg>
      </button>
      <div class="details-node-name" id="details-name"></div>
      <div class="details-meta">
        <span class="details-type-badge" id="details-type"></span>
        <span class="details-degree" id="details-degree"></span>
      </div>
      <button class="details-expand-btn" id="two-hop-btn" onclick="NetworkViz.expandTwoHop()">Show 2-hop neighborhood</button>
    </div>
    <div class="details-connections" id="details-list"></div>
  </aside>

  <!-- About Modal -->
  <div id="aboutModal" class="modal">
    <div class="modal-overlay" onclick="closeAboutModal()"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">About This Project</h2>
        <button class="modal-close" onclick="closeAboutModal()">
          <svg viewBox="0 0 24 24" fill="none">
            <path d="M18 6L6 18M6 6l12 12"/>
          </svg>
        </button>
      </div>
      <div class="modal-body">
        <p>
          This visualization maps the transnational network of Italian-American literary culture, revealing connections between writers, translators, scholars, and cultural institutions. Each node represents either an individual contributor to Italian-American letters or an institution, while edges trace relationships of collaboration, translation, correspondence, and intellectual exchange.
        </p>
        <p>
          The network currently comprises <strong><span id="about-node-count">--</span> nodes</strong> connected by <strong><span id="about-edge-count">--</span> edges</strong>.
        </p>
        <p>
          The network distinguishes between individual actors and institutional entities. Connections are classified as either "affiliations" (institutional relationships) or "personal" (direct interpersonal connections), visualized with subtly different colors.
        </p>
        <h3 style="margin-top:1.2em;margin-bottom:0.4em;font-family:'Cormorant Garamond',serif;font-size:1.1em;">Data Sources</h3>
        <ul style="margin:0.4em 0 1em 1.2em;line-height:1.6;">
          <li><a href="https://transatlantictransfers.polimi.it/atlas">Transatlantic Transfers Atlas</a></li>
          <li>Digitized tables of contents from 103 issues of <em>Divagando</em> (1945&ndash;1957)</li>
          <li>Tables of contents of <em>Il Carroccio</em> (1915&ndash;1930)</li>
          <li>Tables of contents of <em>Atlantica</em> (1923&ndash;1930)</li>
          <li><a href="https://italianamericanimprints.omeka.net/">The Periconi Collection of Italian American Imprints</a></li>
          <li>Wikipedia biographical data</li>
          <li>Metadata from the Italian Sistema Bibliotecario Nazionale (SBN) and OCLC</li>
        </ul>
        <p>
          To learn more, see the <a href="https://doi.org/10.1353/mln.2025.a963658">article published in <em>Modern Language Notes</em></a> (2025).
        </p>
      </div>
      <div class="modal-footer">
        <button class="btn" onclick="closeAboutModal()">Close</button>
      </div>
    </div>
  </div>

  <!-- Footer -->
  <footer>
    <a href="https://stefanomorello.com" target="_blank">&copy; 2025 Stefano Morello</a>
  </footer>

  <script>
    // ═══════════════════════════════════════════════════════════════
    // NETWORK VISUALIZATION MODULE
    // ═══════════════════════════════════════════════════════════════

    const NetworkViz = (function() {
      // Constants
      const DPR = window.devicePixelRatio || 1;
      const DEGREE_THRESHOLDS = [1, 5, 10, 30, 40, 50];

      // Private state
      let svg, width, height, simulation;
      let nodeGroups, labelElements;
      let container, zoom;

      // Canvas link layer
      let linkCanvas, linkCtx;
      let linksData = [];
      let highlightedEdges = new Set();
      let hiddenEdges = new Set();
      let currentZoomTransform = d3.zoomIdentity;

      // Zoom-dependent label visibility
      let currentLabelTier = 'all'; // 'none' | 'hubs' | 'all'
      let pathOrSearchActive = false;

      // Data structures
      let nodesById = new Map();
      let nodesByIdLower = new Map();
      let adjacencyList = new Map();
      let nodeDegrees = new Map();

      // Explorer state
      let explorerNodes = [];

      // State
      let currentPath = [];
      let labelsVisible = true;
      let isSimulationActive = false;
      let renderRequestId = null;
      let isDragging = false;

      // Tooltip
      const tooltip = d3.select("body").append("div").attr("class", "tooltip").style("display", "none");

      // Institution subtype color palette
      const subtypeColors = {
        magazine: '#b8860b',     // Dark goldenrod - periodicals
        publisher: '#8b7355',    // Original sepia - books
        university: '#5d6d7e',   // Slate blue-gray - academia
        organization: '#9a7b4f', // Warm bronze - cultural orgs
        media: '#a67c52',        // Warm copper - broadcast
        business: '#7a6e5d',     // Neutral brown-gray
        event: '#946b4a',        // Terracotta - gatherings
        government: '#5a5d5e',   // Institutional gray
        other: '#8a8070',        // Muted neutral
      };

      const subtypeStrokes = {
        magazine: '#8a6508',
        publisher: '#6d5a44',
        university: '#4a5766',
        organization: '#7a6240',
        media: '#855f3e',
        business: '#5f574a',
        event: '#745338',
        government: '#45484a',
        other: '#6a6558',
      };

      // Get fill color for a node
      function getNodeColor(d) {
        if (d.type === 'person') return '#6b8e9f';
        if (d.type === 'institution' && d.subtype && subtypeColors[d.subtype]) {
          return subtypeColors[d.subtype];
        }
        return '#8b7355'; // Default institution color
      }

      // Get stroke color for a node
      function getNodeStroke(d) {
        if (d.type === 'person') return '#546f7d';
        if (d.type === 'institution' && d.subtype && subtypeStrokes[d.subtype]) {
          return subtypeStrokes[d.subtype];
        }
        return '#6d5a44'; // Default institution stroke
      }

      // Caches
      const pathCache = new Map();
      const searchCache = new Map();
      const communityCache = new Map();
      let communitySizes = new Map();

      // Community detection state
      let communityColorActive = false;
      let preCommunityPositions = null;
      const communityPalette = [
        '#7a9e7e', // sage
        '#b0704e', // terracotta
        '#5e7f8c', // slate blue
        '#b8963e', // ochre
        '#9e7a8a', // dusty rose
        '#6b8a5e', // olive
        '#8a6b5e', // umber
        '#5e6b8a', // steel
        '#8a8a5e', // khaki
        '#7a5e8a', // plum
        '#5e8a7a', // teal
        '#8a5e5e'  // brick
      ];

      // 2-hop state
      let twoHopActive = false;
      let twoHopSourceId = null;

      // Utilities
      function debounce(func, wait) {
        let timeout;
        return function(...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func(...args), wait);
        };
      }

      function throttle(func, limit) {
        let inThrottle;
        return function(...args) {
          if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
          }
        };
      }

      function clusterForce(strength, minSize) {
        let nodes;
        function force(alpha) {
          const centroids = new Map();
          const counts = new Map();
          nodes.forEach(d => {
            const cId = communityCache.get(d.id);
            if (cId === undefined) return;
            if ((communitySizes.get(cId) || 0) < minSize) return;
            if (!centroids.has(cId)) { centroids.set(cId, {x: 0, y: 0}); counts.set(cId, 0); }
            centroids.get(cId).x += d.x;
            centroids.get(cId).y += d.y;
            counts.set(cId, counts.get(cId) + 1);
          });
          centroids.forEach((c, cId) => { c.x /= counts.get(cId); c.y /= counts.get(cId); });
          nodes.forEach(d => {
            const cId = communityCache.get(d.id);
            if (cId === undefined) return;
            if ((communitySizes.get(cId) || 0) < minSize) return;
            const c = centroids.get(cId);
            d.vx += (c.x - d.x) * strength * alpha;
            d.vy += (c.y - d.y) * strength * alpha;
          });
        }
        force.initialize = function(_) { nodes = _; };
        return force;
      }

      function autoFitNetwork() {
        if (!nodeGroups || nodeGroups.empty()) return;

        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;

        nodeGroups.each(function(d) {
          minX = Math.min(minX, d.x);
          maxX = Math.max(maxX, d.x);
          minY = Math.min(minY, d.y);
          maxY = Math.max(maxY, d.y);
        });

        const padding = 50;
        minX -= padding;
        maxX += padding;
        minY -= padding;
        maxY += padding;

        const networkWidth = maxX - minX;
        const networkHeight = maxY - minY;
        const scaleX = width / networkWidth;
        const scaleY = height / networkHeight;
        let scale = Math.max(0.1, Math.min(Math.min(scaleX, scaleY), 1.5));

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        const transform = d3.zoomIdentity
          .translate(width / 2, height / 2)
          .scale(scale)
          .translate(-centerX, -centerY);

        svg.transition()
          .duration(1000)
          .call(zoom.transform, transform);
      }

      function init() {
        try {
          showLoadingIndicator();
          setupCanvas();
          loadData();
        } catch (err) {
          console.error('Init error:', err);
          updateLoadingStatus('Error: ' + err.message, 0);
        }
      }

      function showLoadingIndicator() {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
          overlay.style.display = 'flex';
          overlay.classList.remove('fade-out');
        }
      }

      function updateLoadingStatus(status, progress) {
        const statusEl = document.querySelector('.loading-status');
        const progressBar = document.getElementById('progress-bar');
        if (statusEl) statusEl.textContent = status;
        if (progressBar && progress !== undefined) progressBar.style.width = progress + '%';
      }

      function hideLoadingIndicator() {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
          overlay.classList.add('fade-out');
          setTimeout(() => overlay.style.display = 'none', 500);
        }
      }

      function setupCanvas() {
        svg = d3.select("#canvas");
        const rect = svg.node().getBoundingClientRect();
        width = rect.width || window.innerWidth;
        height = rect.height || window.innerHeight - 56;

        svg.attr("width", width).attr("height", height);

        // Initialize link canvas
        linkCanvas = document.getElementById('link-canvas');
        linkCanvas.width = width * DPR;
        linkCanvas.height = height * DPR;
        linkCanvas.style.width = width + 'px';
        linkCanvas.style.height = height + 'px';
        linkCtx = linkCanvas.getContext('2d');
        linkCtx.scale(DPR, DPR);

        zoom = d3.zoom()
          .scaleExtent([0.05, 10])
          .on("zoom", throttle((e) => {
            currentZoomTransform = e.transform;
            container.attr("transform", e.transform);
            drawCanvasLinks();
            updateLabelVisibility(e.transform.k);
          }, 16));

        svg.call(zoom);
        container = svg.append("g");
      }

      function updateLabelVisibility(scale) {
        if (pathOrSearchActive) return; // Don't change labels during highlights

        let newTier;
        if (scale < 0.3) newTier = 'none';
        else if (scale < 0.8) newTier = 'hubs';
        else newTier = 'all';

        if (newTier === currentLabelTier) return;
        currentLabelTier = newTier;

        if (!labelElements) return;

        if (newTier === 'none') {
          labelElements.style("display", "none");
        } else if (newTier === 'hubs') {
          labelElements.style("display", d => (nodeDegrees.get(d.id) || 0) >= 10 ? null : "none");
        } else {
          labelElements.style("display", null);
        }
      }

      function drawCanvasLinks() {
        if (!linkCtx || linksData.length === 0) return;

        linkCtx.save();
        linkCtx.setTransform(DPR, 0, 0, DPR, 0, 0);
        linkCtx.clearRect(0, 0, width, height);

        const t = currentZoomTransform;
        // Scale line width with zoom to match SVG stroke scaling behavior
        const scaledWidth = Math.max(0.5, 1.5 * t.k);

        // Draw normal links
        linkCtx.globalAlpha = 0.4;
        linkCtx.strokeStyle = '#c4b5a0';
        linkCtx.lineWidth = scaledWidth;
        linkCtx.beginPath();

        const personalLinks = [];
        const highlightLinks = [];
        const crossCommunityLinks = [];
        const drawnEdges = new Set();

        for (let i = 0; i < linksData.length; i++) {
          const l = linksData[i];
          const edgeKey = l._edgeKey;

          // Skip duplicate edges (same pair drawn twice due to A→B and B→A)
          if (drawnEdges.has(edgeKey)) continue;
          drawnEdges.add(edgeKey);

          if (hiddenEdges.has(edgeKey)) continue;

          if (highlightedEdges.has(edgeKey)) {
            highlightLinks.push(l);
            continue;
          }

          // Separate cross-community edges when community coloring is active
          if (communityColorActive) {
            const sCid = communityCache.get(l.source.id || l.source);
            const tCid = communityCache.get(l.target.id || l.target);
            if (sCid !== tCid) {
              crossCommunityLinks.push(l);
              continue;
            }
          }

          if (l.type === 'personal') {
            personalLinks.push(l);
            continue;
          }

          const sx = t.applyX(l.source.x);
          const sy = t.applyY(l.source.y);
          const tx = t.applyX(l.target.x);
          const ty = t.applyY(l.target.y);
          linkCtx.moveTo(sx, sy);
          linkCtx.lineTo(tx, ty);
        }
        linkCtx.stroke();

        // Draw personal links (same opacity, subtler color difference)
        if (personalLinks.length > 0) {
          linkCtx.globalAlpha = 0.4;
          linkCtx.strokeStyle = '#b09a8a';
          linkCtx.lineWidth = scaledWidth;
          linkCtx.beginPath();
          for (let i = 0; i < personalLinks.length; i++) {
            const l = personalLinks[i];
            const sx = t.applyX(l.source.x);
            const sy = t.applyY(l.source.y);
            const tx = t.applyX(l.target.x);
            const ty = t.applyY(l.target.y);
            linkCtx.moveTo(sx, sy);
            linkCtx.lineTo(tx, ty);
          }
          linkCtx.stroke();
        }

        // Draw cross-community links dimmed
        if (crossCommunityLinks.length > 0) {
          linkCtx.globalAlpha = 0.08;
          linkCtx.strokeStyle = '#c4b5a0';
          linkCtx.lineWidth = scaledWidth * 0.5;
          linkCtx.beginPath();
          for (let i = 0; i < crossCommunityLinks.length; i++) {
            const l = crossCommunityLinks[i];
            const sx = t.applyX(l.source.x);
            const sy = t.applyY(l.source.y);
            const tx = t.applyX(l.target.x);
            const ty = t.applyY(l.target.y);
            linkCtx.moveTo(sx, sy);
            linkCtx.lineTo(tx, ty);
          }
          linkCtx.stroke();
        }

        // Draw highlighted links on top
        if (highlightLinks.length > 0) {
          linkCtx.globalAlpha = 0.9;
          linkCtx.strokeStyle = '#c4a35a';
          linkCtx.lineWidth = Math.max(1.5, 3 * t.k);
          linkCtx.beginPath();
          for (let i = 0; i < highlightLinks.length; i++) {
            const l = highlightLinks[i];
            const sx = t.applyX(l.source.x);
            const sy = t.applyY(l.source.y);
            const tx = t.applyX(l.target.x);
            const ty = t.applyY(l.target.y);
            linkCtx.moveTo(sx, sy);
            linkCtx.lineTo(tx, ty);
          }
          linkCtx.stroke();
        }

        linkCtx.restore();
      }

      async function loadData() {
        try {
          updateLoadingStatus('Loading network data...', 20);

          let data;
          // Try API first (when served from Flask editor), then fall back to static file
          const apiUrl = window.location.port === '5001'
            ? '/api/graph.json'
            : null;

          try {
            if (apiUrl) {
              data = await d3.json(apiUrl);
            } else {
              data = await d3.json("graph.json");
            }
          } catch (err) {
            // Fallback: try relative path
            const basePath = window.location.href.substring(0, window.location.href.lastIndexOf('/'));
            data = await d3.json(basePath + '/graph.json');
          }

          updateLoadingStatus('Processing relationships...', 40);
          processData(data);

          updateLoadingStatus('Computing layout...', 55);
          initializeSimulation(data);

          updateLoadingStatus('Rendering network...', 75);
          renderNetwork(data);

          updateLoadingStatus('Detecting communities...', 85);
          runCommunityDetection();

          updateLoadingStatus('Finalizing...', 90);
          setupEventHandlers();

          setTimeout(() => {
            initializeAutocomplete();
            // Initialize filter UI - show subtype pills by default (no filters active)
            initializeFilterUI();
          }, 500);

          setTimeout(() => {
            updateLoadingStatus('Ready', 100);
            setTimeout(hideLoadingIndicator, 500);
          }, 2500);

        } catch (error) {
          console.error("Load error:", error);
          updateLoadingStatus('Failed to load: ' + error.message, 0);
          setTimeout(hideLoadingIndicator, 2000);
        }
      }

      function processData(data) {
        data.nodes.forEach(node => {
          nodesById.set(node.id, node);
          nodesByIdLower.set(node.id.toLowerCase(), node);
          adjacencyList.set(node.id, new Set());
          nodeDegrees.set(node.id, 0);
        });

        data.links.forEach(link => {
          const sourceId = typeof link.source === 'string' ? link.source : link.source.id;
          const targetId = typeof link.target === 'string' ? link.target : link.target.id;

          if (adjacencyList.has(sourceId) && adjacencyList.has(targetId)) {
            adjacencyList.get(sourceId).add(targetId);
            adjacencyList.get(targetId).add(sourceId);
            nodeDegrees.set(sourceId, nodeDegrees.get(sourceId) + 1);
            nodeDegrees.set(targetId, nodeDegrees.get(targetId) + 1);
          }
        });
      }

      function initializeSimulation(data) {
        const nodeCount = data.nodes.length;
        const angleStep = (2 * Math.PI) / nodeCount;
        const radius = Math.min(width, height) * 0.35;

        data.nodes.forEach((node, i) => {
          if (!node.x && !node.y) {
            const angle = i * angleStep;
            node.x = width / 2 + radius * Math.cos(angle) + (Math.random() - 0.5) * 20;
            node.y = height / 2 + radius * Math.sin(angle) + (Math.random() - 0.5) * 20;
          }
          node.vx = 0;
          node.vy = 0;
        });

        const baseForces = {
          linkDistance: 300,
          linkStrength: 0.15,
          chargeStrength: -2500,
          collisionRadius: 35
        };

        simulation = d3.forceSimulation(data.nodes)
          .force("link", d3.forceLink(data.links)
            .id(d => d.id)
            .distance(d => {
              const sourceDegree = nodeDegrees.get(d.source.id || d.source) || 1;
              const targetDegree = nodeDegrees.get(d.target.id || d.target) || 1;
              const avgDegree = (sourceDegree + targetDegree) / 2;
              return baseForces.linkDistance * (1 + Math.log(avgDegree) * 0.1);
            })
            .strength(baseForces.linkStrength))
          .force("charge", d3.forceManyBody()
            .strength(d => {
              const degree = nodeDegrees.get(d.id) || 1;
              return baseForces.chargeStrength * (1 + Math.log(degree) * 0.15);
            })
            .distanceMax(500)
            .theta(1.2))
          .force("center", d3.forceCenter(width / 2, height / 2).strength(0.02))
          .force("collision", d3.forceCollide()
            .radius(d => {
              const degree = nodeDegrees.get(d.id) || 1;
              return baseForces.collisionRadius + Math.min(degree * 0.5, 20);
            })
            .strength(0.7)
            .iterations(1))
          .velocityDecay(0.7)
          .alphaDecay(0.04)
          .alphaMin(0.001)
          .alpha(0.5);

        simulation.baseForces = baseForces;
        simulation.on("tick", onTick);

        setTimeout(() => {
          if (!isDragging) {
            simulation.stop();
            isSimulationActive = false;
            setTimeout(autoFitNetwork, 200);
          }
        }, 3000);
      }

      function onTick() {
        if (!renderRequestId) {
          renderRequestId = requestAnimationFrame(() => {
            updatePositions();
            renderRequestId = null;
          });
        }
      }

      function updatePositions() {
        if (nodeGroups) nodeGroups.attr("transform", d => `translate(${d.x}, ${d.y})`);
        drawCanvasLinks();
      }

      function renderNetwork(data) {
        // Store links data for canvas rendering (no SVG lines)
        linksData = data.links;
        // Pre-compute edge keys for fast Set lookups
        linksData.forEach(l => {
          const sourceId = typeof l.source === 'string' ? l.source : l.source.id;
          const targetId = typeof l.target === 'string' ? l.target : l.target.id;
          l._edgeKey = [sourceId, targetId].sort().join('--');
        });

        nodeGroups = container.append("g")
          .attr("class", "nodes")
          .selectAll("g.node")
          .data(data.nodes)
          .join("g")
          .classed("node", true)
          .call(createOptimizedDrag());

        nodeGroups.append("circle")
          .attr("r", d => {
            const degree = nodeDegrees.get(d.id) || 1;
            return 10 + Math.min(Math.sqrt(degree) * 3, 20);
          })
          .style("fill", d => getNodeColor(d))
          .style("stroke", d => getNodeStroke(d))
          .style("stroke-width", 2);

        labelElements = nodeGroups.append("text")
          .text(d => d.id)
          .attr("dx", d => {
            const degree = nodeDegrees.get(d.id) || 1;
            return 10 + Math.min(Math.sqrt(degree) * 3, 20) + 5;
          })
          .attr("dy", 5)
          .attr("class", "label")
          .style("opacity", labelsVisible ? 1 : 0)
          .style("font-size", "12px")
          .style("font-weight", d => (nodeDegrees.get(d.id) || 1) > 10 ? "600" : "400");

        nodeGroups
          .on("mouseenter", handleNodeMouseEnter)
          .on("mouseleave", handleNodeMouseLeave)
          .on("click", handleNodeClick);

        // Initial canvas draw
        drawCanvasLinks();
      }

      function createOptimizedDrag() {
        return d3.drag()
          .on("start", (e, d) => {
            isDragging = true;
            d.fx = d.x;
            d.fy = d.y;
            if (!e.active && simulation.alpha() <= simulation.alphaMin()) {
              simulation.alphaTarget(0.01).restart();
              isSimulationActive = true;
            }
          })
          .on("drag", (e, d) => {
            d.fx = e.x;
            d.fy = e.y;
            d.x = e.x;
            d.y = e.y;

            if (nodeGroups) {
              nodeGroups.filter(n => n === d).attr("transform", `translate(${d.x}, ${d.y})`);
              drawCanvasLinks();
            }
          })
          .on("end", (e, d) => {
            isDragging = false;
            if (!e.active) {
              simulation.alphaTarget(0);
              setTimeout(() => {
                if (!isDragging) {
                  simulation.stop();
                  isSimulationActive = false;
                }
              }, 200);
            }
            d.fx = null;
            d.fy = null;
          });
      }

      const handleNodeMouseEnter = throttle((e, d) => {
        const degree = nodeDegrees.get(d.id);
        tooltip.html(`<strong>${d.id}</strong><br>Connections: ${degree}`)
          .style("left", (e.pageX + 10) + "px")
          .style("top", (e.pageY - 10) + "px")
          .style("display", "block");
      }, 100);

      function handleNodeMouseLeave() {
        tooltip.style("display", "none");
      }

      function handleNodeClick(e, d) {
        e.stopPropagation();
        highlightNode(d);
        showNodeDetails(d);
      }

      function highlightNode(node) {
        // Reset 2-hop if switching nodes
        if (twoHopSourceId && twoHopSourceId !== node.id) {
          twoHopActive = false;
          twoHopSourceId = null;
          const btn = document.getElementById('two-hop-btn');
          if (btn) btn.textContent = 'Show 2-hop neighborhood';
        }

        const connectedNodes = new Set([node.id]);
        adjacencyList.get(node.id).forEach(id => connectedNodes.add(id));

        nodeGroups.style("opacity", d => connectedNodes.has(d.id) ? 1 : 0.1);

        // Force-show labels for connected nodes
        pathOrSearchActive = true;
        labelElements.style("display", d => connectedNodes.has(d.id) ? null : "none");

        // Update canvas: show only edges where BOTH endpoints are in the connected set
        hiddenEdges.clear();
        highlightedEdges.clear();
        linksData.forEach(l => {
          const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
          const targetId = typeof l.target === 'object' ? l.target.id : l.target;
          if (!connectedNodes.has(sourceId) || !connectedNodes.has(targetId)) {
            hiddenEdges.add(l._edgeKey);
          }
        });
        drawCanvasLinks();
        updateExportButtonVisibility();
      }

      function showNodeDetails(node) {
        const panel = document.getElementById('node-details');
        const nameEl = document.getElementById('details-name');
        const typeEl = document.getElementById('details-type');
        const degreeEl = document.getElementById('details-degree');
        const listEl = document.getElementById('details-list');

        const degree = nodeDegrees.get(node.id) || 0;
        const neighbors = adjacencyList.get(node.id) || new Set();

        nameEl.textContent = node.id;

        const nodeType = node.type || 'unknown';
        typeEl.className = 'details-type-badge ' + (nodeType === 'institution' ? 'institution' : 'person');
        // Show subtype if available for institutions
        if (nodeType === 'institution' && node.subtype) {
          typeEl.textContent = node.subtype.charAt(0).toUpperCase() + node.subtype.slice(1);
          typeEl.style.backgroundColor = subtypeColors[node.subtype] || '#8b7355';
        } else {
          typeEl.textContent = nodeType === 'institution' ? 'Institution' : 'Person';
          typeEl.style.backgroundColor = '';
        }

        degreeEl.textContent = degree + ' connection' + (degree !== 1 ? 's' : '');

        // Build connections list grouped by type
        const connections = [];
        neighbors.forEach(id => {
          const n = nodesById.get(id);
          if (n) connections.push({ id: n.id, type: n.type || 'unknown' });
        });
        connections.sort((a, b) => a.id.localeCompare(b.id));

        const institutions = connections.filter(c => c.type === 'institution');
        const persons = connections.filter(c => c.type !== 'institution');

        let html = '';
        if (persons.length > 0) {
          html += '<div class="details-section-heading">Persons (' + persons.length + ')</div>';
          persons.forEach(c => {
            html += '<div class="details-connection-item" data-node="' + c.id.replace(/"/g, '&quot;') + '">'
              + '<span class="details-connection-dot person"></span>'
              + '<span class="details-connection-name">' + c.id + '</span></div>';
          });
        }
        if (institutions.length > 0) {
          html += '<div class="details-section-heading">Institutions (' + institutions.length + ')</div>';
          institutions.forEach(c => {
            html += '<div class="details-connection-item" data-node="' + c.id.replace(/"/g, '&quot;') + '">'
              + '<span class="details-connection-dot institution"></span>'
              + '<span class="details-connection-name">' + c.id + '</span></div>';
          });
        }
        if (connections.length === 0) {
          html = '<div class="details-empty">No connections found</div>';
        }

        listEl.innerHTML = html;

        // Click handler for connection items to navigate
        listEl.querySelectorAll('.details-connection-item').forEach(item => {
          item.addEventListener('click', () => {
            const targetId = item.dataset.node;
            const targetNode = nodesById.get(targetId);
            if (targetNode) {
              highlightNode(targetNode);
              showNodeDetails(targetNode);
            }
          });
        });

        // Update 2-hop button state
        const twoHopBtn = document.getElementById('two-hop-btn');
        if (twoHopBtn) {
          twoHopBtn.textContent = (twoHopActive && twoHopSourceId === node.id)
            ? 'Show direct only'
            : 'Show 2-hop neighborhood';
        }

        panel.classList.add('open');
      }

      function setupEventHandlers() {
        window.searchHandler = debounce(handleSearch, 300);

        const degreeRange = document.getElementById("degree-range");
        degreeRange.addEventListener("input", throttle(handleDegreeFilter, 50));
        handleDegreeFilter({ target: degreeRange });

        window.addEventListener("resize", debounce(handleResize, 250));
      }

      function handleSearch(e) {
        const term = e.target.value.trim().toLowerCase();
        if (!term) {
          resetView();
          return;
        }

        if (searchCache.has(term)) {
          const cached = searchCache.get(term);
          applySearchResults(cached.matched, cached.connected);
          return;
        }

        const regex = new RegExp(term, 'i');
        const matched = [];
        const connected = new Set();

        nodesById.forEach((node, id) => {
          if (regex.test(id)) {
            matched.push(node);
            adjacencyList.get(id).forEach(connId => connected.add(nodesById.get(connId)));
          }
        });

        searchCache.set(term, { matched, connected });
        if (searchCache.size > 50) {
          searchCache.delete(searchCache.keys().next().value);
        }

        applySearchResults(matched, connected);
      }

      function applySearchResults(matched, connected) {
        if (matched.length > 0) {
          const matchedSet = new Set(matched);
          const important = new Set([...matched, ...connected]);
          const importantIds = new Set();
          important.forEach(n => importantIds.add(n.id));
          const matchedIds = new Set();
          matchedSet.forEach(n => matchedIds.add(n.id));

          nodeGroups.style("opacity", d => important.has(d) ? 1 : 0.1);

          // Force-show labels for matched nodes
          pathOrSearchActive = true;
          labelElements.style("display", d => importantIds.has(d.id) ? null : "none");

          // Update canvas links
          hiddenEdges.clear();
          highlightedEdges.clear();
          linksData.forEach(l => {
            const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
            const targetId = typeof l.target === 'object' ? l.target.id : l.target;
            const sourceMatched = matchedIds.has(sourceId);
            const targetMatched = matchedIds.has(targetId);
            const sourceImportant = importantIds.has(sourceId);
            const targetImportant = importantIds.has(targetId);
            if (!((sourceMatched && targetImportant) || (targetMatched && sourceImportant))) {
              hiddenEdges.add(l._edgeKey);
            }
          });
          drawCanvasLinks();
          updateExportButtonVisibility();

          centerNodes(matched);
        }
      }

      function handleDegreeFilter(e) {
        const sliderValue = parseInt(e.target.value);
        currentDegreeThreshold = DEGREE_THRESHOLDS[sliderValue];
        document.getElementById("degree-label").textContent = currentDegreeThreshold + "+";
        applyAllFilters();
      }

      // ═══════════════════════════════════════════════════════════════
      // TYPE/SUBTYPE FILTERING (Multi-select pill-based)
      // ═══════════════════════════════════════════════════════════════

      // Multi-select filter state
      const selectedTypes = new Set();      // 'person', 'institution'
      const selectedSubtypes = new Set();   // 'magazine', 'publisher', etc.
      let currentDegreeThreshold = 1;
      let filterMode = 'or';                // 'or' or 'and' for subtype matching

      function filterByType(type) {
        const subtypeLabel = document.getElementById('subtype-label');
        const subtypePills = document.getElementById('subtype-pills');

        if (type === 'all') {
          // Clear all selections
          selectedTypes.clear();
          selectedSubtypes.clear();
        } else {
          // Toggle type selection
          if (selectedTypes.has(type)) {
            selectedTypes.delete(type);
            // If deselecting institution, clear subtypes
            if (type === 'institution') {
              selectedSubtypes.clear();
            }
          } else {
            selectedTypes.add(type);
          }
        }

        // Update pill UI
        updateFilterPillUI();

        // Show/hide subtype pills
        // Show if: institution selected, no type filter, OR subtypes already selected (so user can see what's filtering)
        const showSubtypes = selectedTypes.has('institution') || selectedTypes.size === 0 || selectedSubtypes.size > 0;
        subtypeLabel.style.display = showSubtypes ? 'block' : 'none';
        subtypePills.style.display = showSubtypes ? 'flex' : 'none';

        updateFilterModeToggle();
        applyAllFilters();
      }

      function filterBySubtype(subtype) {
        // Toggle subtype selection
        if (selectedSubtypes.has(subtype)) {
          selectedSubtypes.delete(subtype);
        } else {
          selectedSubtypes.add(subtype);
        }

        // Update pill UI
        updateFilterPillUI();
        updateFilterModeToggle();
        applyAllFilters();
      }

      function setFilterMode(mode) {
        filterMode = mode;
        // Update button states
        document.querySelectorAll('.filter-mode-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.mode === mode);
        });
        applyAllFilters();
      }

      function updateFilterModeToggle() {
        const toggle = document.getElementById('filter-mode-toggle');
        const personSelected = selectedTypes.has('person');
        const multipleSubtypes = selectedSubtypes.size >= 2;
        // Show toggle when person type selected AND 2+ subtypes selected
        toggle.style.display = (personSelected && multipleSubtypes) ? 'flex' : 'none';
      }

      function updateFilterPillUI() {
        const typePills = document.querySelectorAll('#type-pills > .filter-pill');
        const subtypePills = document.querySelectorAll('#subtype-pills .filter-pill');
        const noFilters = selectedTypes.size === 0 && selectedSubtypes.size === 0;

        // Update type pills
        typePills.forEach(pill => {
          const pillType = pill.dataset.filter;
          if (pillType === 'all') {
            pill.classList.toggle('active', noFilters);
          } else {
            pill.classList.toggle('active', selectedTypes.has(pillType));
          }
          pill.classList.remove('dimmed');
        });

        // Update subtype pills
        subtypePills.forEach(pill => {
          const pillSubtype = pill.dataset.subtype;
          pill.classList.toggle('active', selectedSubtypes.has(pillSubtype));
          pill.classList.remove('dimmed');
        });
      }

      function initializeFilterUI() {
        // Show subtype pills by default (when no type filters are active)
        const subtypeLabel = document.getElementById('subtype-label');
        const subtypePills = document.getElementById('subtype-pills');
        if (subtypeLabel) subtypeLabel.style.display = 'block';
        if (subtypePills) subtypePills.style.display = 'flex';

        // Set "All" as active initially
        updateFilterPillUI();
      }

      function applyAllFilters() {
        if (!nodeGroups) return;

        // Get degree threshold
        const sliderValue = parseInt(document.getElementById('degree-range')?.value || 0);
        currentDegreeThreshold = DEGREE_THRESHOLDS[sliderValue];

        // Apply filters to nodes and count visible
        let visibleCount = 0;
        const totalCount = nodesById.size;

        nodeGroups.each(function(d) {
          const isVisible = isNodeVisible(d);
          d3.select(this).style("opacity", isVisible ? 1 : 0.08);
          if (isVisible) visibleCount++;
        });

        // Update filter count display
        const filterCountEl = document.getElementById('filter-count');
        if (filterCountEl) {
          const hasFilters = selectedTypes.size > 0 || selectedSubtypes.size > 0 || currentDegreeThreshold > 1;
          if (hasFilters && visibleCount < totalCount) {
            filterCountEl.textContent = `Showing ${visibleCount.toLocaleString()} of ${totalCount.toLocaleString()} nodes`;
            filterCountEl.style.display = 'block';
          } else {
            filterCountEl.style.display = 'none';
          }
        }

        // Update canvas link visibility
        hiddenEdges.clear();
        highlightedEdges.clear();

        if (linksData) {
          linksData.forEach(l => {
            const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
            const targetId = typeof l.target === 'object' ? l.target.id : l.target;
            const sourceNode = nodesById.get(sourceId);
            const targetNode = nodesById.get(targetId);

            if (!isNodeVisible(sourceNode) || !isNodeVisible(targetNode)) {
              hiddenEdges.add(l._edgeKey);
            }
          });
        }

        drawCanvasLinks();
        updateExportButtonVisibility();
      }

      function isConnectedToSelectedSubtypes(node) {
        // Check if a person node is connected to institutions with selected subtypes
        const neighbors = adjacencyList.get(node.id);
        if (!neighbors) return false;

        // Collect which selected subtypes this node is connected to
        const connectedSubtypes = new Set();
        for (const neighborId of neighbors) {
          const neighbor = nodesById.get(neighborId);
          if (neighbor && neighbor.type === 'institution') {
            if (selectedSubtypes.has(neighbor.subtype)) {
              connectedSubtypes.add(neighbor.subtype);
            }
            if (selectedSubtypes.has('uncategorized') && !neighbor.subtype) {
              connectedSubtypes.add('uncategorized');
            }
          }
        }

        if (filterMode === 'and') {
          // AND: must be connected to ALL selected subtypes
          return connectedSubtypes.size === selectedSubtypes.size;
        } else {
          // OR: connected to ANY selected subtype
          return connectedSubtypes.size > 0;
        }
      }

      function isNodeVisible(node) {
        if (!node) return false;
        const degree = nodeDegrees.get(node.id) || 0;

        // Check degree threshold
        if (degree < currentDegreeThreshold) return false;

        const hasTypeFilters = selectedTypes.size > 0;
        const hasSubtypeFilters = selectedSubtypes.size > 0;

        // No filters = show all
        if (!hasTypeFilters && !hasSubtypeFilters) return true;

        // Check if node matches any selected type
        if (hasTypeFilters && !hasSubtypeFilters) {
          return selectedTypes.has(node.type);
        }

        // Check if node matches any selected subtype (institutions only)
        if (hasSubtypeFilters) {
          if (node.type !== 'institution') {
            // Person nodes: only show if connected to an institution with selected subtype
            if (hasTypeFilters && selectedTypes.has('person')) {
              return isConnectedToSelectedSubtypes(node);
            }
            return false;
          }
          // Institution: check subtype match
          if (selectedSubtypes.has('uncategorized')) {
            if (!node.subtype) return true;
          }
          return selectedSubtypes.has(node.subtype);
        }

        return true;
      }

      function resetFilters() {
        selectedTypes.clear();
        selectedSubtypes.clear();
        currentDegreeThreshold = 1;
        filterMode = 'or';

        // Reset UI
        updateFilterPillUI();
        document.getElementById('subtype-label').style.display = 'none';
        document.getElementById('subtype-pills').style.display = 'none';
        document.getElementById('filter-mode-toggle').style.display = 'none';
        // Reset filter mode buttons
        document.querySelectorAll('.filter-mode-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.mode === 'or');
        });
        const filterCountEl = document.getElementById('filter-count');
        if (filterCountEl) filterCountEl.style.display = 'none';
      }

      function handleResize() {
        const rect = svg.node().getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        svg.attr("width", width).attr("height", height);

        // Resize link canvas
        linkCanvas.width = width * DPR;
        linkCanvas.height = height * DPR;
        linkCanvas.style.width = width + 'px';
        linkCanvas.style.height = height + 'px';
        linkCtx = linkCanvas.getContext('2d');
        linkCtx.scale(DPR, DPR);
        drawCanvasLinks();

        if (simulation) {
          simulation.force("center", d3.forceCenter(width / 2, height / 2).strength(0.05));
          simulation.alpha(0.1).restart();
          setTimeout(() => { if (!isDragging) simulation.stop(); }, 500);
        }
      }

      function resetView() {
        nodeGroups.style("opacity", 1);
        hiddenEdges.clear();
        highlightedEdges.clear();
        pathOrSearchActive = false;
        drawCanvasLinks();
        updateExportButtonVisibility();
        currentLabelTier = null;
        updateLabelVisibility(currentZoomTransform.k);
        autoFitNetwork();
        searchCache.clear();
      }

      function centerNodes(nodesToCenter) {
        if (!nodesToCenter || nodesToCenter.length === 0) return;

        const xExtent = d3.extent(nodesToCenter, d => d.x);
        const yExtent = d3.extent(nodesToCenter, d => d.y);
        const centerX = (xExtent[0] + xExtent[1]) / 2;
        const centerY = (yExtent[0] + yExtent[1]) / 2;

        let scale = 1;
        if (xExtent[1] - xExtent[0] > 0 && yExtent[1] - yExtent[0] > 0) {
          scale = Math.min(8, 0.9 / Math.max(
            (xExtent[1] - xExtent[0]) / width,
            (yExtent[1] - yExtent[0]) / height
          ));
        }
        if (nodesToCenter.length === 1) scale = Math.min(scale, 2);

        svg.transition()
          .duration(750)
          .call(zoom.transform, d3.zoomIdentity
            .translate(-centerX * scale + width / 2, -centerY * scale + height / 2)
            .scale(scale));
      }

      // Path finding
      function findPath() {
        // Legacy support: called with 2 explorer nodes
        if (explorerNodes.length === 2) {
          exploreConnections();
        }
      }

      function exploreConnections() {
        if (explorerNodes.length < 2) {
          alert("Please add at least 2 nodes to explore.");
          return;
        }

        if (explorerNodes.length === 2) {
          // Two nodes: use existing path finding
          const startInput = explorerNodes[0];
          const endInput = explorerNodes[1];

          const cacheKey = `${startInput.toLowerCase()}_${endInput.toLowerCase()}`;
          if (pathCache.has(cacheKey)) {
            const cached = pathCache.get(cacheKey);
            if (cached.nodes.size > 0) {
              highlightAllConnections(cached);
            } else {
              alert("No connection found between these nodes.");
            }
            return;
          }

          const result = findAllConnections(startInput.toLowerCase(), endInput.toLowerCase());
          pathCache.set(cacheKey, result);
          if (pathCache.size > 100) pathCache.delete(pathCache.keys().next().value);

          if (result.nodes.size > 0) {
            highlightAllConnections(result);
          } else {
            alert("No connections found between these nodes.");
          }
        } else {
          // 3+ nodes: find shared connections (intersection of neighbor sets)
          findSharedConnections(explorerNodes);
        }
      }

      function findSharedConnections(selectedNames) {
        // Get adjacency sets for each selected node
        const sets = [];
        const selectedIds = new Set();

        for (const name of selectedNames) {
          const node = nodesById.get(name) || nodesByIdLower.get(name.toLowerCase());
          if (!node) {
            alert(`Node "${name}" not found in the network.`);
            return;
          }
          selectedIds.add(node.id);
          const neighbors = adjacencyList.get(node.id);
          if (neighbors) {
            sets.push(new Set(neighbors));
          } else {
            sets.push(new Set());
          }
        }

        // Compute intersection of all neighbor sets
        if (sets.length === 0) return;
        let shared = new Set(sets[0]);
        for (let i = 1; i < sets.length; i++) {
          const next = sets[i];
          shared = new Set([...shared].filter(id => next.has(id)));
        }

        // Remove selected nodes from the shared set (they aren't "shared connections")
        selectedIds.forEach(id => shared.delete(id));

        if (shared.size === 0) {
          const pathInfoEl = document.getElementById('path-info');
          if (pathInfoEl) {
            pathInfoEl.style.display = 'block';
            pathInfoEl.innerHTML = '<span class="explorer-result-count">No shared connections found between all selected nodes.</span>';
          }
          return;
        }

        // Build the set of all nodes and edges to show
        const connectedNodes = new Set([...selectedIds, ...shared]);
        const connectedEdges = new Set();

        // Add edges from each selected node to each shared node
        linksData.forEach(l => {
          const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
          const targetId = typeof l.target === 'object' ? l.target.id : l.target;
          const sourceIsSelected = selectedIds.has(sourceId);
          const targetIsSelected = selectedIds.has(targetId);
          const sourceIsShared = shared.has(sourceId);
          const targetIsShared = shared.has(targetId);

          if ((sourceIsSelected && targetIsShared) || (targetIsSelected && sourceIsShared)) {
            connectedEdges.add(l._edgeKey);
          }
        });

        // Show result info
        const pathInfoEl = document.getElementById('path-info');
        if (pathInfoEl) {
          pathInfoEl.style.display = 'block';
          pathInfoEl.innerHTML = '<span class="explorer-result-count">' + shared.size + ' shared connection' + (shared.size !== 1 ? 's' : '') + ' found</span>'
            + '<button class="btn" style="margin-top:8px" onclick="NetworkViz.exportSubgraph()">Export Subgraph</button>';
        }

        // Highlight: dim unrelated nodes, show only relevant edges
        nodeGroups.style("opacity", d => connectedNodes.has(d.id) ? 1 : 0)
          .style("display", d => connectedNodes.has(d.id) ? "block" : "none");

        // Style selected nodes distinctly
        nodeGroups.select("circle")
          .style("stroke", function(d) {
            if (selectedIds.has(d.id)) return "#c4a35a";
            return d.type === 'institution' ? "#6d5a44" : "#546f7d";
          })
          .style("stroke-width", d => selectedIds.has(d.id) ? 4 : 2);

        // Force-show labels
        pathOrSearchActive = true;
        labelElements.style("display", d => connectedNodes.has(d.id) ? null : "none");

        // Canvas edges
        hiddenEdges.clear();
        highlightedEdges.clear();
        linksData.forEach(l => {
          if (connectedEdges.has(l._edgeKey)) {
            highlightedEdges.add(l._edgeKey);
          } else {
            hiddenEdges.add(l._edgeKey);
          }
        });
        drawCanvasLinks();
        updateExportButtonVisibility();

        // Center the view on shared nodes
        const allVisible = Array.from(connectedNodes).map(id => nodesById.get(id)).filter(Boolean);
        centerNodes(allVisible);
      }

      function addExplorerNode(name) {
        if (!name || explorerNodes.includes(name)) return;
        explorerNodes.push(name);
        renderExplorerChips();
      }

      function removeExplorerNode(name) {
        explorerNodes = explorerNodes.filter(n => n !== name);
        renderExplorerChips();
      }

      function renderExplorerChips() {
        const container = document.getElementById('explorer-chips');
        if (!container) return;
        container.innerHTML = explorerNodes.map(name =>
          '<span class="explorer-chip">' +
            '<span class="explorer-chip-name">' + name + '</span>' +
            '<button class="explorer-chip-remove" onclick="NetworkViz._removeExplorerNode(\'' + name.replace(/'/g, "\\'") + '\')">' +
              '<svg viewBox="0 0 24 24" fill="none"><path d="M18 6L6 18M6 6l12 12"/></svg>' +
            '</button>' +
          '</span>'
        ).join('');
      }

      class MultiNodeConnectionFinder {
        constructor(allNodes, allLinks, adjacencyList) {
          this.allNodes = allNodes;
          this.allLinks = allLinks;
          this.adjacencyList = adjacencyList;
          this.nodesByIdLower = new Map();
          allNodes.forEach(node => this.nodesByIdLower.set(node.id.toLowerCase(), node));
        }

        findMultiNodeConnections(selectedNodeIds) {
          const normalizedIds = selectedNodeIds.map(id => id.toLowerCase());
          const validNodes = normalizedIds.filter(id => this.nodesByIdLower.has(id));

          if (validNodes.length === 0) return { nodes: new Set(), edges: new Set() };
          if (validNodes.length === 1) return this.findSingleNodeNeighborhood(validNodes[0]);
          if (validNodes.length === 2) return this.findTwoNodePaths(validNodes[0], validNodes[1]);
          return this.findSteinerTree(validNodes);
        }

        findSingleNodeNeighborhood(nodeId) {
          const node = this.nodesByIdLower.get(nodeId);
          const connectedNodes = new Set([node.id]);
          const connectedEdges = new Set();

          const neighbors = this.adjacencyList.get(node.id) || new Set();
          neighbors.forEach(neighbor => {
            connectedNodes.add(neighbor);
            connectedEdges.add([node.id, neighbor].sort().join('--'));
          });

          return { nodes: connectedNodes, edges: connectedEdges };
        }

        findTwoNodePaths(startId, endId) {
          const startNode = this.nodesByIdLower.get(startId);
          const endNode = this.nodesByIdLower.get(endId);

          if (startNode.id === endNode.id) return this.findSingleNodeNeighborhood(startId);

          const connectedNodes = new Set();
          const connectedEdges = new Set();
          const shortestLength = this.bfsShortestPath(startNode.id, endNode.id);

          if (shortestLength === -1) return { nodes: new Set(), edges: new Set() };

          const maxPathLength = 4;
          const pathLengthTolerance = 1;
          const paths = this.findAllPathsBFS(startNode.id, endNode.id, Math.min(maxPathLength, shortestLength + pathLengthTolerance));

          paths.forEach(path => {
            path.forEach(nodeId => connectedNodes.add(nodeId));
            for (let i = 0; i < path.length - 1; i++) {
              connectedEdges.add([path[i], path[i + 1]].sort().join('--'));
            }
          });

          this.addCommonNeighbors(startNode.id, endNode.id, connectedNodes, connectedEdges);
          return { nodes: connectedNodes, edges: connectedEdges };
        }

        findSteinerTree(terminalNodeIds) {
          const connectedNodes = new Set();
          const connectedEdges = new Set();
          const terminals = terminalNodeIds.map(id => this.nodesByIdLower.get(id).id);
          const maxPathLength = 4;
          const pathLengthTolerance = 1;
          const allPairPaths = new Map();
          const shortestDistances = new Map();

          for (let i = 0; i < terminals.length; i++) {
            for (let j = i + 1; j < terminals.length; j++) {
              const source = terminals[i];
              const target = terminals[j];
              const key = [source, target].sort().join('--');
              const shortestDist = this.bfsShortestPath(source, target);

              if (shortestDist !== -1) {
                shortestDistances.set(key, shortestDist);
                const maxLength = Math.min(maxPathLength, shortestDist + pathLengthTolerance);
                const paths = this.findAllPathsBFS(source, target, maxLength);
                if (paths.length > 0) allPairPaths.set(key, paths);
              }
            }
          }

          const mstEdges = this.primMST(terminals, shortestDistances);

          mstEdges.forEach(([source, target]) => {
            const key = [source, target].sort().join('--');
            const paths = allPairPaths.get(key);
            if (paths) {
              paths.forEach(path => {
                path.forEach(nodeId => connectedNodes.add(nodeId));
                for (let i = 0; i < path.length - 1; i++) {
                  connectedEdges.add([path[i], path[i + 1]].sort().join('--'));
                }
              });
            }
          });

          for (let i = 0; i < terminals.length; i++) {
            for (let j = i + 1; j < terminals.length; j++) {
              const source = terminals[i];
              const target = terminals[j];
              const neighbors = this.adjacencyList.get(source);
              if (neighbors && neighbors.has(target)) {
                connectedNodes.add(source);
                connectedNodes.add(target);
                connectedEdges.add([source, target].sort().join('--'));
              }
              this.addCommonNeighbors(source, target, connectedNodes, connectedEdges);
            }
          }

          return { nodes: connectedNodes, edges: connectedEdges };
        }

        bfsShortestPath(start, end) {
          const queue = [[start, 0]];
          const visited = new Set();

          while (queue.length > 0) {
            const [node, distance] = queue.shift();
            if (node === end) return distance;
            if (visited.has(node)) continue;
            visited.add(node);

            const neighbors = this.adjacencyList.get(node);
            if (neighbors) {
              neighbors.forEach(neighbor => {
                if (!visited.has(neighbor)) queue.push([neighbor, distance + 1]);
              });
            }
          }
          return -1;
        }

        findAllPathsBFS(start, end, maxLength) {
          const allPaths = [];
          const queue = [[start]];

          while (queue.length > 0) {
            const path = queue.shift();
            const currentNode = path[path.length - 1];

            if (path.length > maxLength + 1) continue;
            if (currentNode === end) {
              allPaths.push([...path]);
              continue;
            }

            const neighbors = this.adjacencyList.get(currentNode);
            if (neighbors) {
              neighbors.forEach(neighbor => {
                if (!path.includes(neighbor)) queue.push([...path, neighbor]);
              });
            }
          }
          return allPaths;
        }

        addCommonNeighbors(startId, endId, connectedNodes, connectedEdges) {
          const startNeighbors = this.adjacencyList.get(startId) || new Set();
          const endNeighbors = this.adjacencyList.get(endId) || new Set();

          startNeighbors.forEach(neighbor => {
            if (endNeighbors.has(neighbor)) {
              connectedNodes.add(neighbor);
              connectedNodes.add(startId);
              connectedNodes.add(endId);
              connectedEdges.add([startId, neighbor].sort().join('--'));
              connectedEdges.add([endId, neighbor].sort().join('--'));
            }
          });
        }

        primMST(nodes, distances) {
          if (nodes.length === 0) return [];
          const mstEdges = [];
          const inMST = new Set([nodes[0]]);

          while (inMST.size < nodes.length) {
            let minEdge = null;
            let minDistance = Infinity;

            inMST.forEach(u => {
              nodes.forEach(v => {
                if (!inMST.has(v)) {
                  const key = [u, v].sort().join('--');
                  const dist = distances.get(key);
                  if (dist !== undefined && dist < minDistance) {
                    minDistance = dist;
                    minEdge = [u, v];
                  }
                }
              });
            });

            if (minEdge) {
              mstEdges.push(minEdge);
              inMST.add(minEdge[1]);
            } else break;
          }
          return mstEdges;
        }
      }

      function findAllConnections(startId, endId) {
        const finder = new MultiNodeConnectionFinder(
          Array.from(nodesById.values()),
          linksData,
          adjacencyList
        );

        const result = finder.findTwoNodePaths(startId.toLowerCase(), endId.toLowerCase());
        const startNode = nodesByIdLower.get(startId.toLowerCase());
        const endNode = nodesByIdLower.get(endId.toLowerCase());

        if (!startNode || !endNode) {
          return { nodes: new Set(), edges: new Set(), startNode: null, endNode: null, shortestPathLength: -1, pathCount: 0, pathsByLength: new Map() };
        }

        const shortestLength = finder.bfsShortestPath(startNode.id, endNode.id);
        const pathsByLength = new Map();
        let totalPaths = 0;

        if (shortestLength !== -1) {
          const maxPathLength = 4;
          const tolerance = 1;
          for (let length = shortestLength; length <= Math.min(maxPathLength, shortestLength + tolerance); length++) {
            const pathsAtLength = finder.findAllPathsBFS(startNode.id, endNode.id, length)
              .filter(path => path.length - 1 === length);
            if (pathsAtLength.length > 0) {
              pathsByLength.set(length, pathsAtLength.length);
              totalPaths += pathsAtLength.length;
            }
          }
        }

        const startNeighbors = adjacencyList.get(startNode.id) || new Set();
        const endNeighbors = adjacencyList.get(endNode.id) || new Set();
        const commonNeighbors = Array.from(startNeighbors).filter(n => endNeighbors.has(n));

        return {
          nodes: result.nodes || new Set(),
          edges: result.edges || new Set(),
          startNode: startNode.id,
          endNode: endNode.id,
          shortestPathLength: shortestLength,
          pathCount: totalPaths,
          pathsByLength,
          commonNeighbors: commonNeighbors.length
        };
      }

      function highlightAllConnections(result) {
        clearPath();

        const { nodes: connectedNodes, edges: connectedEdges, startNode, endNode, shortestPathLength, pathCount, pathsByLength, commonNeighbors } = result;

        const pathInfoEl = document.getElementById('path-info');
        if (shortestPathLength !== undefined && pathInfoEl) {
          let infoText = '';
          if (shortestPathLength === -1) {
            infoText = 'No connection found between these nodes';
          } else if (shortestPathLength === 1) {
            infoText = 'Direct relationship identified';
            if (pathCount > 1 && pathsByLength) {
              const additionalPaths = pathCount - (pathsByLength.get(1) || 1);
              if (additionalPaths > 0) infoText += ` + ${additionalPaths} alternative path${additionalPaths > 1 ? 's' : ''}`;
            }
          } else {
            infoText = `${shortestPathLength} degrees of separation`;
            if (pathsByLength && pathsByLength.size > 0) {
              const pathDetails = [];
              pathsByLength.forEach((count, length) => {
                if (count > 0) pathDetails.push(`${count} path${count > 1 ? 's' : ''} at ${length}`);
              });
              if (pathDetails.length > 0) infoText += ` (${pathDetails.join(', ')})`;
            }
          }
          if ((commonNeighbors || 0) > 0) infoText += ` | ${commonNeighbors} shared contact${commonNeighbors > 1 ? 's' : ''}`;

          pathInfoEl.innerHTML = infoText + '<button class="btn" style="margin-top:8px" onclick="NetworkViz.exportSubgraph()">Export Subgraph</button>';
          pathInfoEl.style.display = 'block';
        }

        nodeGroups.style("opacity", d => connectedNodes.has(d.id) ? 1 : 0)
          .style("display", d => connectedNodes.has(d.id) ? "block" : "none");

        // Update canvas: hide non-path edges, highlight path edges
        hiddenEdges.clear();
        highlightedEdges.clear();
        linksData.forEach(l => {
          if (connectedEdges.has(l._edgeKey)) {
            highlightedEdges.add(l._edgeKey);
          } else {
            hiddenEdges.add(l._edgeKey);
          }
        });
        pathOrSearchActive = true;
        drawCanvasLinks();
        updateExportButtonVisibility();

        nodeGroups.select("circle").each(function(d) {
          if (connectedNodes.has(d.id)) {
            const isEndpoint = (d.id === startNode || d.id === endNode);
            d3.select(this)
              .classed("highlight-node", true)
              .style("stroke", isEndpoint ? "#c4a35a" : "#a08a6e")
              .style("stroke-width", isEndpoint ? "4px" : "3px")
              .style("fill", function() {
                if (d.id === startNode) return "#4a7c59";
                if (d.id === endNode) return "#8b3a3a";
                return getNodeColor(d);
              });
          }
        });

        labelElements.style("opacity", d => connectedNodes.has(d.id) ? 1 : 0)
          .style("display", d => connectedNodes.has(d.id) ? "block" : "none");

        centerNodes(Array.from(connectedNodes).map(id => nodesById.get(id)));
      }

      // ═══════════════════════════════════════════════════════════════
      // COMMUNITY DETECTION
      // ═══════════════════════════════════════════════════════════════

      function runCommunityDetection() {
        if (communityCache.size > 0) return; // Already computed

        // Label propagation algorithm for community detection
        const labels = new Map();
        const nodeIds = Array.from(nodesById.keys());

        // Initialize: each node gets its own label
        nodeIds.forEach((id, i) => labels.set(id, i));

        // Iterate until convergence or max iterations
        const maxIterations = 20;
        for (let iter = 0; iter < maxIterations; iter++) {
          let changed = false;

          // Shuffle node order for each iteration
          const shuffled = [...nodeIds];
          for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
          }

          for (const nodeId of shuffled) {
            const neighbors = adjacencyList.get(nodeId);
            if (!neighbors || neighbors.size === 0) continue;

            // Count labels among neighbors
            const labelCounts = new Map();
            neighbors.forEach(neighborId => {
              const lbl = labels.get(neighborId);
              labelCounts.set(lbl, (labelCounts.get(lbl) || 0) + 1);
            });

            // Find most common label
            let maxCount = 0;
            let bestLabel = labels.get(nodeId);
            labelCounts.forEach((count, lbl) => {
              if (count > maxCount) {
                maxCount = count;
                bestLabel = lbl;
              }
            });

            if (bestLabel !== labels.get(nodeId)) {
              labels.set(nodeId, bestLabel);
              changed = true;
            }
          }

          if (!changed) break;
        }

        // Remap labels to contiguous integers
        const labelMap = new Map();
        let nextId = 0;
        labels.forEach((label, nodeId) => {
          if (!labelMap.has(label)) {
            labelMap.set(label, nextId++);
          }
          communityCache.set(nodeId, labelMap.get(label));
        });

        const communityCount = labelMap.size;

        // Compute community sizes
        communitySizes = new Map();
        communityCache.forEach((cId) => {
          communitySizes.set(cId, (communitySizes.get(cId) || 0) + 1);
        });

        const majorCount = [...communitySizes.values()].filter(s => s >= 20).length;
        const infoEl = document.getElementById('community-info');
        if (infoEl) {
          infoEl.textContent = communityCount + ' communities detected (' + majorCount + ' major, spatially clustered)';
        }
      }

      function toggleCommunities() {
        if (communityCache.size === 0) runCommunityDetection();
        communityColorActive = !communityColorActive;

        const btn = document.getElementById('community-toggle');
        const infoEl = document.getElementById('community-info');

        if (communityColorActive) {
          btn.classList.add('active');
          if (infoEl) infoEl.style.display = 'block';
          // Save current positions so we can restore on deactivation
          preCommunityPositions = new Map();
          simulation.nodes().forEach(d => {
            preCommunityPositions.set(d.id, {x: d.x, y: d.y});
          });
          nodeGroups.select("circle").style("fill", d => {
            const cId = communityCache.get(d.id);
            return cId !== undefined ? communityPalette[cId % communityPalette.length] : '#999';
          });
          // Weaken cross-community links so clusters can separate
          simulation.force("link").strength(link => {
            const sCid = communityCache.get(link.source.id || link.source);
            const tCid = communityCache.get(link.target.id || link.target);
            return sCid !== undefined && sCid === tCid ? 0.15 : 0.005;
          });
          simulation.force("cluster", clusterForce(0.12, 20));
          simulation.alpha(0.5).restart();
          setTimeout(() => { if (!isDragging) { simulation.stop(); autoFitNetwork(); } }, 4000);
        } else {
          btn.classList.remove('active');
          if (infoEl) infoEl.style.display = 'none';
          nodeGroups.select("circle").style("fill", d => getNodeColor(d));
          // Restore uniform link strength and original positions
          simulation.force("link").strength(0.15);
          simulation.force("cluster", null);
          if (preCommunityPositions) {
            simulation.nodes().forEach(d => {
              const pos = preCommunityPositions.get(d.id);
              if (pos) { d.x = pos.x; d.y = pos.y; d.vx = 0; d.vy = 0; }
            });
            preCommunityPositions = null;
          }
          simulation.alpha(0.05).restart();
          setTimeout(() => { if (!isDragging) { simulation.stop(); autoFitNetwork(); } }, 1000);
        }
      }

      function getNodeColorWithCommunity(d) {
        if (communityColorActive) {
          const cId = communityCache.get(d.id);
          return cId !== undefined ? communityPalette[cId % communityPalette.length] : '#999';
        }
        return getNodeColor(d);
      }

      // ═══════════════════════════════════════════════════════════════
      // SUBGRAPH EXPORT
      // ═══════════════════════════════════════════════════════════════

      function exportSubgraph() {
        const visibleNodes = [];
        nodeGroups.each(function(d) {
          const el = d3.select(this);
          const opacity = parseFloat(el.style("opacity"));
          const display = el.style("display");
          if (display !== "none" && opacity > 0.05) {
            visibleNodes.push({ id: d.id, type: d.type || 'unknown' });
          }
        });

        const visibleIds = new Set(visibleNodes.map(n => n.id));
        const visibleLinks = [];
        linksData.forEach(l => {
          if (hiddenEdges.has(l._edgeKey)) return;
          const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
          const targetId = typeof l.target === 'object' ? l.target.id : l.target;
          if (visibleIds.has(sourceId) && visibleIds.has(targetId)) {
            visibleLinks.push({ source: sourceId, target: targetId });
          }
        });

        const subgraph = { nodes: visibleNodes, links: visibleLinks };
        const blob = new Blob([JSON.stringify(subgraph, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.download = 'subgraph-export.json';
        a.href = url;
        a.click();
        URL.revokeObjectURL(url);
      }

      function updateExportButtonVisibility() {
        const btn = document.getElementById('export-subgraph-btn');
        if (btn) {
          btn.style.display = (hiddenEdges.size > 0 || pathOrSearchActive) ? 'block' : 'none';
        }
      }

      // ═══════════════════════════════════════════════════════════════
      // 2-HOP NEIGHBORHOODS
      // ═══════════════════════════════════════════════════════════════

      function expandTwoHop() {
        const nameEl = document.getElementById('details-name');
        const nodeId = nameEl ? nameEl.textContent : null;
        if (!nodeId || !nodesById.has(nodeId)) return;

        const btn = document.getElementById('two-hop-btn');
        if (twoHopActive && twoHopSourceId === nodeId) {
          // Revert to direct neighbors
          twoHopActive = false;
          twoHopSourceId = null;
          if (btn) btn.textContent = 'Show 2-hop neighborhood';
          highlightNode(nodesById.get(nodeId));
          return;
        }

        twoHopActive = true;
        twoHopSourceId = nodeId;
        if (btn) btn.textContent = 'Show direct only';

        const oneHop = adjacencyList.get(nodeId) || new Set();
        const twoHop = new Set();
        oneHop.forEach(neighbor => {
          const neighborsOfNeighbor = adjacencyList.get(neighbor) || new Set();
          neighborsOfNeighbor.forEach(nn => {
            if (nn !== nodeId && !oneHop.has(nn)) {
              twoHop.add(nn);
            }
          });
        });

        const allRelevant = new Set([nodeId, ...oneHop, ...twoHop]);

        // Set node opacities
        nodeGroups.style("opacity", d => {
          if (d.id === nodeId || oneHop.has(d.id)) return 1;
          if (twoHop.has(d.id)) return 0.6;
          return 0.05;
        }).style("display", d => allRelevant.has(d.id) ? null : null);

        // Labels: show for source + 1-hop, hide for 2-hop and others
        pathOrSearchActive = true;
        labelElements.style("display", d => {
          if (d.id === nodeId || oneHop.has(d.id)) return null;
          return "none";
        });

        // Edges: show edges where both endpoints are in allRelevant
        hiddenEdges.clear();
        highlightedEdges.clear();
        linksData.forEach(l => {
          const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
          const targetId = typeof l.target === 'object' ? l.target.id : l.target;
          if (!allRelevant.has(sourceId) || !allRelevant.has(targetId)) {
            hiddenEdges.add(l._edgeKey);
          } else if (sourceId === nodeId || targetId === nodeId) {
            highlightedEdges.add(l._edgeKey);
          }
        });

        drawCanvasLinks();
        updateExportButtonVisibility();

        // Center on the 2-hop subgraph
        const nodesToCenter = Array.from(allRelevant).map(id => nodesById.get(id)).filter(Boolean);
        centerNodes(nodesToCenter);
      }

      function clearPath() {
        const pathInfoEl = document.getElementById('path-info');
        if (pathInfoEl) {
          pathInfoEl.style.display = 'none';
          pathInfoEl.innerHTML = '';
        }

        // Clear explorer chips
        explorerNodes = [];
        renderExplorerChips();
        const explorerInput = document.getElementById('explorer-input');
        if (explorerInput) explorerInput.value = '';

        // Reset 2-hop state
        twoHopActive = false;
        twoHopSourceId = null;
        const twoHopBtn = document.getElementById('two-hop-btn');
        if (twoHopBtn) twoHopBtn.textContent = 'Show 2-hop neighborhood';

        nodeGroups.style("opacity", 1).style("display", "block");
        nodeGroups.select("circle")
          .classed("highlight-node", false)
          .style("stroke", d => d.type === 'institution' ? "#6d5a44" : "#546f7d")
          .style("stroke-width", 2)
          .style("fill", d => getNodeColor(d));

        // Reset canvas link state
        hiddenEdges.clear();
        highlightedEdges.clear();
        pathOrSearchActive = false;
        drawCanvasLinks();

        // Restore label visibility based on current zoom tier
        currentLabelTier = null; // Force recalculation
        updateLabelVisibility(currentZoomTransform.k);

        // Close details panel
        document.getElementById('node-details').classList.remove('open');

        // Reset type/subtype filters
        resetFilters();
        applyAllFilters();

        updateExportButtonVisibility();
      }

      async function exportPNG() {
        try {
          // Force-show all labels for export
          const prevTier = currentLabelTier;
          labelElements.style("display", null);

          const bbox = container.node().getBBox();
          const padding = 50;
          const exportWidth = bbox.width + padding * 2;
          const exportHeight = bbox.height + padding * 2;

          const exportCanvas = document.createElement('canvas');
          exportCanvas.width = exportWidth;
          exportCanvas.height = exportHeight;
          const ctx = exportCanvas.getContext('2d');

          // Draw background
          ctx.fillStyle = '#f7f4ed';
          ctx.fillRect(0, 0, exportWidth, exportHeight);

          // Draw links onto export canvas (in network coordinates)
          ctx.save();
          ctx.translate(-bbox.x + padding, -bbox.y + padding);
          ctx.lineWidth = 1.5;

          // Normal affiliation links
          ctx.globalAlpha = 0.4;
          ctx.strokeStyle = '#c4b5a0';
          ctx.beginPath();
          for (let i = 0; i < linksData.length; i++) {
            const l = linksData[i];
            if (hiddenEdges.has(l._edgeKey)) continue;
            if (highlightedEdges.has(l._edgeKey)) continue;
            if (l.type === 'personal') continue;
            ctx.moveTo(l.source.x, l.source.y);
            ctx.lineTo(l.target.x, l.target.y);
          }
          ctx.stroke();

          // Personal links
          ctx.globalAlpha = 0.5;
          ctx.strokeStyle = '#b07070';
          ctx.beginPath();
          for (let i = 0; i < linksData.length; i++) {
            const l = linksData[i];
            if (hiddenEdges.has(l._edgeKey)) continue;
            if (highlightedEdges.has(l._edgeKey)) continue;
            if (l.type !== 'personal') continue;
            ctx.moveTo(l.source.x, l.source.y);
            ctx.lineTo(l.target.x, l.target.y);
          }
          ctx.stroke();

          // Highlighted links
          if (highlightedEdges.size > 0) {
            ctx.globalAlpha = 0.9;
            ctx.strokeStyle = '#c4a35a';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < linksData.length; i++) {
              const l = linksData[i];
              if (!highlightedEdges.has(l._edgeKey)) continue;
              ctx.moveTo(l.source.x, l.source.y);
              ctx.lineTo(l.target.x, l.target.y);
            }
            ctx.stroke();
          }
          ctx.restore();

          // Render SVG nodes/labels on top
          const clonedSvg = svg.node().cloneNode(true);
          const svgNS = "http://www.w3.org/2000/svg";
          const styleEl = document.createElementNS(svgNS, "style");
          styleEl.innerHTML = `
            .label { font-size: 12px; font-family: Georgia, serif; fill: #3d3d3d; }
          `;
          clonedSvg.insertBefore(styleEl, clonedSvg.firstChild);
          clonedSvg.setAttribute("width", exportWidth);
          clonedSvg.setAttribute("height", exportHeight);

          // Adjust the transform of the container group in the clone
          const containerGroup = clonedSvg.querySelector('g');
          if (containerGroup) {
            containerGroup.setAttribute("transform", `translate(${-bbox.x + padding}, ${-bbox.y + padding})`);
          }

          const svgString = new XMLSerializer().serializeToString(clonedSvg);
          await canvg.Canvg.fromString(ctx, svgString).render();

          const a = document.createElement('a');
          a.download = 'italian-american-literary-network.png';
          a.href = exportCanvas.toDataURL();
          a.click();

          // Restore label visibility
          currentLabelTier = null;
          updateLabelVisibility(currentZoomTransform.k);
        } catch (error) {
          console.error("Export error:", error);
          alert("Unable to export image. Please try again.");
        }
      }

      function fullReset() {
        // Reset community colors and clustering force
        communityColorActive = false;
        simulation.force("cluster", null);
        const communityBtn = document.getElementById('community-toggle');
        if (communityBtn) communityBtn.classList.remove('active');
        const communityInfo = document.getElementById('community-info');
        if (communityInfo) communityInfo.style.display = 'none';

        clearPath();
        resetView();

        nodeGroups.select("circle")
          .style("fill", d => getNodeColor(d))
          .style("stroke", d => getNodeStroke(d))
          .style("stroke-width", 2)
          .classed("highlight-node", false);

        document.getElementById("search").value = "";
        const startNode = document.getElementById("start-node");
        if (startNode) startNode.value = "";
        const endNode = document.getElementById("end-node");
        if (endNode) endNode.value = "";
        document.getElementById("degree-range").value = "0";
        document.getElementById("degree-label").textContent = "1+";

        // Reset type filters
        resetFilters();
        document.getElementById('node-details').classList.remove('open');

        searchCache.clear();
        pathCache.clear();
        updateExportButtonVisibility();
      }

      function initializeAutocomplete() {
        if (nodesById.size === 0) return;

        const names = Array.from(nodesById.keys()).sort();
        ['search', 'explorer-input'].forEach(id => {
          const input = document.getElementById(id);
          if (input) {
            const existing = document.getElementById(id + 'autocomplete-list');
            if (existing) existing.remove();
            const newInput = input.cloneNode(true);
            input.parentNode.replaceChild(newInput, input);
          }
        });

        setTimeout(() => {
          const searchInput = document.getElementById("search");
          const explorerInput = document.getElementById("explorer-input");

          if (searchInput) {
            createOptimizedAutocomplete(searchInput, names);
            searchInput.addEventListener("input", window.searchHandler);
          }
          if (explorerInput) {
            createOptimizedAutocomplete(explorerInput, names, true);
          }
        }, 100);
      }

      function createOptimizedAutocomplete(input, items, addAsChip) {
        if (!input || !items || items.length === 0) return;

        let currentFocus = -1;
        const searchIndex = items.map(item => ({ original: item, lower: item.toLowerCase() }));

        const handleAutocomplete = function() {
          const val = this.value.trim().toLowerCase();
          closeAllLists();
          if (!val || val.length < 1) return;

          currentFocus = -1;
          const autocompleteList = document.createElement("DIV");
          autocompleteList.setAttribute("id", this.id + "autocomplete-list");
          autocompleteList.setAttribute("class", "autocomplete-items");
          if (!this.parentNode.style.position || this.parentNode.style.position === 'static') {
            this.parentNode.style.position = 'relative';
          }
          this.parentNode.appendChild(autocompleteList);

          let matchCount = 0;
          const maxMatches = 15;
          const matches = [];

          for (let i = 0; i < searchIndex.length && matchCount < maxMatches; i++) {
            if (searchIndex[i].lower.startsWith(val)) {
              matches.push({ item: searchIndex[i], priority: 1 });
              matchCount++;
            }
          }

          if (matchCount < maxMatches) {
            for (let i = 0; i < searchIndex.length && matchCount < maxMatches; i++) {
              if (!searchIndex[i].lower.startsWith(val) && searchIndex[i].lower.includes(val)) {
                matches.push({ item: searchIndex[i], priority: 2 });
                matchCount++;
              }
            }
          }

          matches.sort((a, b) => a.priority - b.priority);

          matches.forEach(match => {
            const searchItem = match.item;
            if (searchItem.lower.includes(val)) {
              const item = searchItem.original;
              const matchIndex = searchItem.lower.indexOf(val);
              const itemDiv = document.createElement("DIV");
              const strongEl = document.createElement('strong');
              strongEl.textContent = item.substr(matchIndex, val.length);

              itemDiv.textContent = item.substr(0, matchIndex);
              itemDiv.appendChild(strongEl);
              itemDiv.appendChild(document.createTextNode(item.substr(matchIndex + val.length)));
              itemDiv.dataset.value = item;

              itemDiv.addEventListener("click", function() {
                if (addAsChip) {
                  addExplorerNode(this.dataset.value);
                  input.value = '';
                  closeAllLists();
                } else {
                  input.value = this.dataset.value;
                  closeAllLists();
                  input.dispatchEvent(new Event('input', { bubbles: true }));
                }
              });

              autocompleteList.appendChild(itemDiv);
            }
          });
        };

        input.addEventListener("input", handleAutocomplete);
        input.addEventListener("focus", function(e) {
          if (this.value.length >= 1) handleAutocomplete.call(this, e);
        });

        input.addEventListener("keydown", function(e) {
          let items = document.getElementById(this.id + "autocomplete-list");
          if (items) items = items.getElementsByTagName("div");

          if (e.keyCode === 40) {
            currentFocus++;
            addActive(items);
          } else if (e.keyCode === 38) {
            currentFocus--;
            addActive(items);
          } else if (e.keyCode === 13) {
            e.preventDefault();
            if (currentFocus > -1 && items) {
              items[currentFocus].click();
            } else if (addAsChip && input.value.trim()) {
              // If no autocomplete item selected, try to add the typed value
              const typed = input.value.trim();
              const match = searchIndex.find(s => s.lower === typed.toLowerCase());
              if (match) {
                addExplorerNode(match.original);
                input.value = '';
                closeAllLists();
              }
            }
          } else if (e.keyCode === 27) {
            closeAllLists();
          }
        });

        function addActive(items) {
          if (!items) return;
          removeActive(items);
          if (currentFocus >= items.length) currentFocus = 0;
          if (currentFocus < 0) currentFocus = items.length - 1;
          items[currentFocus].classList.add("autocomplete-active");
        }

        function removeActive(items) {
          for (let i = 0; i < items.length; i++) items[i].classList.remove("autocomplete-active");
        }

        function closeAllLists(elmnt) {
          const items = document.getElementsByClassName("autocomplete-items");
          for (let i = items.length - 1; i >= 0; i--) {
            if (elmnt != items[i] && elmnt != input) items[i].parentNode.removeChild(items[i]);
          }
        }

        document.addEventListener("click", e => closeAllLists(e.target));
        input.addEventListener("blur", () => setTimeout(() => closeAllLists(), 200));
      }

      return {
        init,
        findPath,
        exploreConnections,
        clearPath,
        exportPNG,
        fullReset,
        toggleCommunities,
        exportSubgraph,
        expandTwoHop: expandTwoHop,
        autoFit: autoFitNetwork,
        _removeExplorerNode: removeExplorerNode,
        filterByType,
        filterBySubtype,
        setFilterMode,
        resetFilters,
        getStats: function() {
          return { nodes: nodesById ? nodesById.size : 0, edges: linksData ? linksData.length : 0 };
        },
        _resyncCanvas: function(w, h) {
          width = w;
          height = h;
          svg.attr("width", width).attr("height", height);
          linkCtx = linkCanvas.getContext('2d');
          drawCanvasLinks();
        }
      };
    })();

    // Global functions
    function toggleSidebar() {
      const sidebar = document.getElementById("sidebar");
      const backdrop = document.getElementById("sidebar-backdrop");
      sidebar.classList.toggle("hidden");

      // Toggle backdrop on mobile
      const isMobile = window.innerWidth <= 768;
      if (isMobile && backdrop) {
        if (sidebar.classList.contains("hidden")) {
          backdrop.classList.remove("visible");
        } else {
          backdrop.classList.add("visible");
        }
      }

      // Re-sync canvas dimensions after sidebar transition completes
      setTimeout(() => {
        const svgRect = document.getElementById("canvas").getBoundingClientRect();
        const linkCanvasEl = document.getElementById("link-canvas");
        const dpr = window.devicePixelRatio || 1; // Local scope - outside NetworkViz module
        linkCanvasEl.width = svgRect.width * dpr;
        linkCanvasEl.height = svgRect.height * dpr;
        linkCanvasEl.style.width = svgRect.width + 'px';
        linkCanvasEl.style.height = svgRect.height + 'px';
        const ctx = linkCanvasEl.getContext('2d');
        ctx.scale(dpr, dpr);
        if (typeof NetworkViz !== 'undefined') {
          NetworkViz._resyncCanvas(svgRect.width, svgRect.height);
        }
      }, 350); // After CSS transition (300ms + buffer)
    }

    function openAboutModal() {
      const modal = document.getElementById('aboutModal');
      modal.classList.remove('closing');
      modal.classList.add('show');
      const stats = NetworkViz.getStats();
      const nodeEl = document.getElementById('about-node-count');
      const edgeEl = document.getElementById('about-edge-count');
      if (nodeEl && stats.nodes > 0) nodeEl.textContent = stats.nodes.toLocaleString();
      if (edgeEl && stats.edges > 0) edgeEl.textContent = stats.edges.toLocaleString();
    }

    function closeAboutModal() {
      const modal = document.getElementById('aboutModal');
      modal.classList.add('closing');
      setTimeout(() => modal.classList.remove('show', 'closing'), 300);
    }

    function closeNodeDetails() {
      document.getElementById('node-details').classList.remove('open');
    }

    // Initialize
    document.addEventListener("DOMContentLoaded", function() {
      // Hide sidebar by default on mobile
      if (window.innerWidth <= 768) {
        document.getElementById("sidebar").classList.add("hidden");
      }

      if (typeof NetworkViz !== 'undefined' && !window.vizInitialized) {
        window.vizInitialized = true;
        NetworkViz.init();
      }

      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
          const modal = document.getElementById('aboutModal');
          if (modal && modal.classList.contains('show')) closeAboutModal();
          // Also close sidebar on mobile with Escape
          if (window.innerWidth <= 768) {
            const sidebar = document.getElementById("sidebar");
            if (!sidebar.classList.contains("hidden")) {
              toggleSidebar();
            }
          }
        }
      });
    });

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      setTimeout(() => {
        if (typeof NetworkViz !== 'undefined' && !window.vizInitialized) {
          window.vizInitialized = true;
          NetworkViz.init();
        }
      }, 100);
    }
  </script>
</body>
</html>
