<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Divagando & Il Carroccio Network</title>

  <!-- Libraries -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/graphology@0.24.1/dist/graphology.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ngraph.graph@19.1.0/dist/ngraph.graph.min.js"></script>
  <script src="https://unpkg.com/ngraph.path@1.3.1/dist/ngraph.path.min.js"></script>
  <script src="https://unpkg.com/canvg@3.0.7/lib/umd.js"></script>

  <!-- Typography -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400&family=Source+Sans+3:wght@300;400;500;600&display=swap" rel="stylesheet">

  <style>
    /* ═══════════════════════════════════════════════════════════════
       ARCHIVAL LITERARY AESTHETIC
       Inspired by manuscript archives, scholarly libraries, and
       the transatlantic correspondence of mid-century literati
    ═══════════════════════════════════════════════════════════════ */

    :root {
      /* Manuscript palette */
      --parchment: #f7f4ed;
      --parchment-dark: #ebe6da;
      --ink-dark: #1a1a1a;
      --ink-medium: #3d3d3d;
      --ink-light: #6b6b6b;
      --sepia: #8b7355;
      --sepia-light: #a08a6e;
      --sepia-dark: #6d5a44;
      --accent-blue: #4a6670;
      --accent-blue-light: #6b8e9f;
      --rust: #8b5a3c;
      --gold: #c4a35a;
      --shadow: rgba(26, 26, 26, 0.08);
      --shadow-deep: rgba(26, 26, 26, 0.15);

      /* Typography */
      --font-display: 'Cormorant Garamond', Georgia, 'Times New Roman', serif;
      --font-body: 'Source Sans 3', -apple-system, BlinkMacSystemFont, sans-serif;

      /* Spacing */
      --sidebar-width: 300px;
      --header-height: 56px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-body);
      background: var(--parchment);
      color: var(--ink-medium);
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      line-height: 1.5;
    }

    /* ═══════════════════════════════════════════════════════════════
       HEADER
    ═══════════════════════════════════════════════════════════════ */

    #header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: var(--header-height);
      background: linear-gradient(180deg, var(--ink-dark) 0%, #2a2a2a 100%);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 24px;
      z-index: 1000;
      border-bottom: 1px solid var(--sepia-dark);
    }

    .header-title {
      font-family: var(--font-display);
      font-size: 1.5rem;
      font-weight: 500;
      color: var(--parchment);
      letter-spacing: 0.02em;
    }

    .header-title span {
      font-style: italic;
      font-weight: 400;
      opacity: 0.8;
    }

    .header-actions {
      display: flex;
      gap: 12px;
    }

    .header-btn {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      background: transparent;
      border: 1px solid rgba(247, 244, 237, 0.2);
      border-radius: 4px;
      color: var(--parchment);
      font-family: var(--font-body);
      font-size: 0.8rem;
      font-weight: 500;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .header-btn:hover {
      background: rgba(247, 244, 237, 0.1);
      border-color: rgba(247, 244, 237, 0.3);
    }

    .header-btn svg {
      width: 14px;
      height: 14px;
      opacity: 0.8;
    }

    /* ═══════════════════════════════════════════════════════════════
       SIDEBAR
    ═══════════════════════════════════════════════════════════════ */

    #sidebar {
      position: fixed;
      left: 0;
      top: var(--header-height);
      width: var(--sidebar-width);
      height: calc(100vh - var(--header-height));
      background: var(--parchment);
      border-right: 1px solid var(--parchment-dark);
      overflow-y: auto;
      z-index: 900;
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 2px 0 12px var(--shadow);
    }

    #sidebar.hidden {
      transform: translateX(-100%);
    }

    #sidebar::-webkit-scrollbar {
      width: 4px;
    }

    #sidebar::-webkit-scrollbar-track {
      background: transparent;
    }

    #sidebar::-webkit-scrollbar-thumb {
      background: var(--sepia-light);
      border-radius: 2px;
    }

    .sidebar-section {
      padding: 20px;
      border-bottom: 1px solid var(--parchment-dark);
    }

    .sidebar-section:last-child {
      border-bottom: none;
    }

    .section-label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-family: var(--font-display);
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--sepia);
      margin-bottom: 12px;
    }

    .section-label svg {
      width: 14px;
      height: 14px;
      opacity: 0.7;
    }

    .section-title {
      font-family: var(--font-display);
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--ink-dark);
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .help-tip {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      background: var(--sepia);
      color: var(--parchment);
      border-radius: 50%;
      font-size: 10px;
      font-weight: 600;
      cursor: help;
      position: relative;
    }

    .help-tip::after {
      content: attr(data-tip);
      position: absolute;
      left: calc(100% + 8px);
      top: 50%;
      transform: translateY(-50%);
      background: var(--ink-dark);
      color: var(--parchment);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 400;
      white-space: nowrap;
      max-width: 200px;
      white-space: normal;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 100;
      box-shadow: 0 4px 12px var(--shadow-deep);
    }

    .help-tip:hover::after {
      opacity: 1;
    }

    /* Input styles */
    .input-field {
      width: 100%;
      padding: 10px 12px;
      background: #fff;
      border: 1px solid var(--parchment-dark);
      border-radius: 4px;
      font-family: var(--font-body);
      font-size: 0.875rem;
      color: var(--ink-dark);
      transition: all 0.2s ease;
      margin-bottom: 8px;
    }

    .input-field:focus {
      outline: none;
      border-color: var(--sepia);
      box-shadow: 0 0 0 3px rgba(139, 115, 85, 0.1);
    }

    .input-field::placeholder {
      color: var(--ink-light);
    }

    /* Button styles */
    .btn {
      width: 100%;
      padding: 10px 16px;
      background: var(--parchment);
      border: 1px solid var(--sepia);
      border-radius: 4px;
      font-family: var(--font-body);
      font-size: 0.8rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      color: var(--sepia-dark);
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: 6px;
    }

    .btn:hover {
      background: var(--sepia);
      color: var(--parchment);
    }

    .btn:active {
      transform: translateY(1px);
    }

    .btn-row {
      display: flex;
      gap: 8px;
    }

    .btn-row .btn {
      flex: 1;
    }

    /* Slider */
    .slider-wrap {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .slider-wrap input[type="range"] {
      flex: 1;
      -webkit-appearance: none;
      height: 4px;
      background: var(--parchment-dark);
      border-radius: 2px;
      outline: none;
    }

    .slider-wrap input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: var(--sepia);
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .slider-wrap input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    .slider-value {
      min-width: 32px;
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--sepia-dark);
      text-align: right;
    }

    /* Path info display */
    #path-info {
      display: none;
      margin-top: 12px;
      padding: 12px;
      background: rgba(139, 115, 85, 0.08);
      border-left: 3px solid var(--sepia);
      border-radius: 0 4px 4px 0;
      font-size: 0.8rem;
      color: var(--ink-medium);
      line-height: 1.5;
    }

    /* Legend */
    .legend-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
      color: var(--ink-medium);
    }

    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .legend-line {
      width: 20px;
      height: 3px;
      border-radius: 1px;
      flex-shrink: 0;
    }

    .legend-dot.person { background: var(--accent-blue-light); }
    .legend-dot.institution { background: var(--sepia); }
    .legend-line.affiliation { background: #c4b5a0; }
    .legend-line.personal { background: #b07070; }

    /* Toggle button */
    #toggle-sidebar {
      position: fixed;
      top: calc(var(--header-height) + 12px);
      left: 12px;
      width: 36px;
      height: 36px;
      background: var(--ink-dark);
      border: none;
      border-radius: 4px;
      cursor: pointer;
      z-index: 1001;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px var(--shadow-deep);
    }

    #toggle-sidebar:hover {
      background: var(--sepia-dark);
    }

    #toggle-sidebar svg {
      width: 18px;
      height: 18px;
      stroke: var(--parchment);
      stroke-width: 2;
      fill: none;
    }

    #sidebar:not(.hidden) ~ #toggle-sidebar {
      left: calc(var(--sidebar-width) + 12px);
    }

    /* ═══════════════════════════════════════════════════════════════
       AUTOCOMPLETE
    ═══════════════════════════════════════════════════════════════ */

    .autocomplete {
      position: relative;
    }

    .autocomplete-items {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: #fff;
      border: 1px solid var(--parchment-dark);
      border-top: none;
      border-radius: 0 0 4px 4px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      box-shadow: 0 4px 12px var(--shadow);
    }

    .autocomplete-items div {
      padding: 8px 12px;
      font-size: 0.875rem;
      cursor: pointer;
      border-bottom: 1px solid var(--parchment-dark);
      transition: background 0.15s ease;
    }

    .autocomplete-items div:last-child {
      border-bottom: none;
    }

    .autocomplete-items div:hover,
    .autocomplete-active {
      background: var(--parchment-dark);
    }

    .autocomplete-items div strong {
      color: var(--sepia);
    }

    /* ═══════════════════════════════════════════════════════════════
       CANVAS & VISUALIZATION
    ═══════════════════════════════════════════════════════════════ */

    #canvas {
      position: fixed;
      top: var(--header-height);
      left: var(--sidebar-width);
      width: calc(100vw - var(--sidebar-width));
      height: calc(100vh - var(--header-height));
      background:
        radial-gradient(ellipse at center, var(--parchment) 0%, var(--parchment-dark) 100%);
      transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1), width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    #sidebar.hidden ~ #canvas {
      left: 0;
      width: 100vw;
    }

    .tooltip {
      position: absolute;
      padding: 10px 14px;
      background: var(--ink-dark);
      color: var(--parchment);
      border-radius: 4px;
      font-family: var(--font-body);
      font-size: 0.8rem;
      pointer-events: none;
      z-index: 1100;
      box-shadow: 0 4px 12px var(--shadow-deep);
      max-width: 280px;
    }

    .label {
      font-family: var(--font-display);
      font-size: 12px;
      font-weight: 500;
      fill: var(--ink-medium);
      pointer-events: none;
      text-shadow:
        -1px -1px 0 var(--parchment),
        1px -1px 0 var(--parchment),
        -1px 1px 0 var(--parchment),
        1px 1px 0 var(--parchment),
        0 0 8px var(--parchment);
    }

    .link {
      stroke: #c4b5a0;
      stroke-opacity: 0.4;
      stroke-width: 1.5;
      transition: stroke-opacity 0.3s ease;
    }

    .link.personal {
      stroke: #b07070;
      stroke-opacity: 0.5;
    }

    .highlight-path {
      stroke: var(--gold) !important;
      stroke-width: 3px !important;
      stroke-opacity: 0.9 !important;
    }

    .highlight-node {
      stroke: var(--gold) !important;
      stroke-width: 3px !important;
    }

    /* ═══════════════════════════════════════════════════════════════
       LOADING OVERLAY
    ═══════════════════════════════════════════════════════════════ */

    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--parchment);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      transition: opacity 0.5s ease;
    }

    #loading-overlay.fade-out {
      opacity: 0;
      pointer-events: none;
    }

    .loading-content {
      text-align: center;
    }

    .loading-title {
      font-family: var(--font-display);
      font-size: 1.5rem;
      font-weight: 500;
      color: var(--ink-dark);
      margin-bottom: 24px;
      font-style: italic;
    }

    .loading-bar {
      width: 200px;
      height: 3px;
      background: var(--parchment-dark);
      border-radius: 2px;
      overflow: hidden;
      margin-bottom: 16px;
    }

    #progress-bar {
      height: 100%;
      background: var(--sepia);
      width: 0%;
      transition: width 0.3s ease;
    }

    .loading-status {
      font-size: 0.8rem;
      color: var(--ink-light);
    }

    /* ═══════════════════════════════════════════════════════════════
       MODAL
    ═══════════════════════════════════════════════════════════════ */

    .modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .modal.show {
      display: flex;
    }

    .modal-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(26, 26, 26, 0.6);
      backdrop-filter: blur(4px);
    }

    .modal-content {
      position: relative;
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      background: var(--parchment);
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 24px 48px rgba(26, 26, 26, 0.3);
      animation: modalIn 0.3s ease;
    }

    @keyframes modalIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .modal.closing .modal-content {
      animation: modalOut 0.3s ease forwards;
    }

    @keyframes modalOut {
      to {
        opacity: 0;
        transform: translateY(20px);
      }
    }

    .modal-header {
      padding: 24px 24px 16px;
      border-bottom: 1px solid var(--parchment-dark);
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
    }

    .modal-title {
      font-family: var(--font-display);
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--ink-dark);
    }

    .modal-close {
      width: 32px;
      height: 32px;
      background: transparent;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: background 0.2s ease;
    }

    .modal-close:hover {
      background: var(--parchment-dark);
    }

    .modal-close svg {
      width: 20px;
      height: 20px;
      stroke: var(--ink-medium);
      stroke-width: 2;
    }

    .modal-body {
      padding: 24px;
      overflow-y: auto;
      max-height: 50vh;
    }

    .modal-body p {
      margin-bottom: 16px;
      font-size: 0.95rem;
      line-height: 1.7;
      color: var(--ink-medium);
    }

    .modal-body p:last-child {
      margin-bottom: 0;
    }

    .modal-body a {
      color: var(--sepia);
      text-decoration: underline;
      text-underline-offset: 2px;
    }

    .modal-body a:hover {
      color: var(--sepia-dark);
    }

    .modal-footer {
      padding: 16px 24px 24px;
      display: flex;
      justify-content: flex-end;
    }

    .modal-footer .btn {
      width: auto;
      padding: 10px 24px;
    }

    /* ═══════════════════════════════════════════════════════════════
       FOOTER
    ═══════════════════════════════════════════════════════════════ */

    footer {
      position: fixed;
      bottom: 0;
      right: 0;
      padding: 8px 16px;
      font-size: 0.75rem;
      color: var(--ink-light);
      z-index: 100;
    }

    footer a {
      color: var(--ink-light);
      text-decoration: none;
      transition: color 0.2s ease;
    }

    footer a:hover {
      color: var(--sepia);
    }

    /* ═══════════════════════════════════════════════════════════════
       RESPONSIVE
    ═══════════════════════════════════════════════════════════════ */

    @media (max-width: 768px) {
      :root {
        --sidebar-width: 100%;
      }

      #sidebar {
        transform: translateX(-100%);
      }

      #sidebar.show {
        transform: translateX(0);
      }

      #canvas {
        left: 0;
        width: 100vw;
      }

      #toggle-sidebar {
        left: 12px !important;
      }

      .header-title span {
        display: none;
      }
    }
  </style>
</head>
<body>
  <!-- Loading Overlay -->
  <div id="loading-overlay">
    <div class="loading-content">
      <div class="loading-title">Mapping Literary Networks...</div>
      <div class="loading-bar">
        <div id="progress-bar"></div>
      </div>
      <div class="loading-status">Initializing...</div>
    </div>
  </div>

  <!-- Header -->
  <header id="header">
    <h1 class="header-title">Divagando & Il Carroccio <span>Contributors Network</span></h1>
    <div class="header-actions">
      <button class="header-btn" onclick="openAboutModal()">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
          <circle cx="12" cy="12" r="10"/>
          <path d="M12 16v-4M12 8h.01"/>
        </svg>
        About
      </button>
    </div>
  </header>

  <!-- Sidebar Toggle -->
  <button id="toggle-sidebar" onclick="toggleSidebar()" aria-label="Toggle sidebar">
    <svg viewBox="0 0 24 24">
      <line x1="3" y1="6" x2="21" y2="6"/>
      <line x1="3" y1="12" x2="21" y2="12"/>
      <line x1="3" y1="18" x2="21" y2="18"/>
    </svg>
  </button>

  <!-- Sidebar -->
  <aside id="sidebar">
    <!-- Search -->
    <div class="sidebar-section">
      <div class="section-label">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"/>
          <path d="m21 21-4.35-4.35"/>
        </svg>
        Search
      </div>
      <div class="autocomplete">
        <input type="text" id="search" class="input-field" placeholder="Find individuals or institutions...">
      </div>
    </div>

    <!-- Connection Explorer -->
    <div class="sidebar-section">
      <div class="section-title">
        Connection Explorer
        <span class="help-tip" data-tip="Discover paths linking two figures or institutions in the network">?</span>
      </div>
      <div class="autocomplete">
        <input type="text" id="start-node" class="input-field" placeholder="Starting point...">
      </div>
      <div class="autocomplete">
        <input type="text" id="end-node" class="input-field" placeholder="Destination...">
      </div>
      <div class="btn-row">
        <button class="btn" onclick="NetworkViz.findPath()">Trace Path</button>
        <button class="btn" onclick="NetworkViz.clearPath()">Clear</button>
      </div>
      <div id="path-info"></div>
    </div>

    <!-- Density Filter -->
    <div class="sidebar-section">
      <div class="section-title">
        Network Density
        <span class="help-tip" data-tip="Show only nodes with the specified minimum number of connections">?</span>
      </div>
      <div class="slider-wrap">
        <input type="range" id="degree-range" min="0" max="5" value="0">
        <span id="degree-label" class="slider-value">1+</span>
      </div>
    </div>

    <!-- Actions -->
    <div class="sidebar-section">
      <button class="btn" onclick="NetworkViz.exportPNG()">Download Image</button>
      <button class="btn" onclick="NetworkViz.fullReset()">Reset View</button>
    </div>

    <!-- Legend -->
    <div class="sidebar-section">
      <div class="section-label">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="18" height="18" rx="2"/>
          <path d="M3 9h18M9 21V9"/>
        </svg>
        Legend
      </div>
      <div class="legend-grid">
        <div class="legend-item">
          <span class="legend-dot person"></span>
          Person
        </div>
        <div class="legend-item">
          <span class="legend-dot institution"></span>
          Institution
        </div>
        <div class="legend-item">
          <span class="legend-line affiliation"></span>
          Affiliation
        </div>
        <div class="legend-item">
          <span class="legend-line personal"></span>
          Personal
        </div>
      </div>
    </div>
  </aside>

  <!-- Canvas -->
  <svg id="canvas"></svg>

  <!-- About Modal -->
  <div id="aboutModal" class="modal">
    <div class="modal-overlay" onclick="closeAboutModal()"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title">About This Project</h2>
        <button class="modal-close" onclick="closeAboutModal()">
          <svg viewBox="0 0 24 24" fill="none">
            <path d="M18 6L6 18M6 6l12 12"/>
          </svg>
        </button>
      </div>
      <div class="modal-body">
        <p>
          This visualization maps the transnational network of Italian-American literary culture, revealing connections between writers, translators, scholars, and cultural institutions. Each node represents either an individual contributor to Italian-American letters or an institution, while edges trace relationships of collaboration, translation, correspondence, and intellectual exchange.
        </p>
        <p>
          The dataset draws from multiple sources: the <a href="https://transatlantictransfers.polimi.it/atlas">Transatlantic Transfers Atlas</a>, digitized tables of contents from 103 issues of <em>Divagando</em>, Wikipedia biographical data, and metadata from the Italian Sistema Bibliotecario Nazionale (SBN).
        </p>
        <p>
          The network distinguishes between individual actors and institutional entities. Connections are classified as either "affiliations" (institutional relationships) or "personal" (direct interpersonal connections), visualized in different colors.
        </p>
        <p>
          The network comprises over 1,500 nodes connected by nearly 3,000 edges. To learn more, see the <a href="https://doi.org/10.1353/mln.2025.a963658">article published in <em>Modern Language Notes</em></a> (2025).
        </p>
      </div>
      <div class="modal-footer">
        <button class="btn" onclick="closeAboutModal()">Close</button>
      </div>
    </div>
  </div>

  <!-- Footer -->
  <footer>
    <a href="https://stefanomorello.com" target="_blank">&copy; 2025 Stefano Morello</a>
  </footer>

  <script>
    // ═══════════════════════════════════════════════════════════════
    // NETWORK VISUALIZATION MODULE
    // ═══════════════════════════════════════════════════════════════

    const NetworkViz = (function() {
      // Private state
      let svg, width, height, simulation;
      let nodeGroups, linkElements, labelElements;
      let container, zoom;

      // Data structures
      let nodesById = new Map();
      let nodesByIdLower = new Map();
      let adjacencyList = new Map();
      let nodeDegrees = new Map();
      let nodeIndexMap = new Map();

      // State
      let currentPath = [];
      let labelsVisible = true;
      let isSimulationActive = false;
      let renderRequestId = null;
      let isDragging = false;

      // Colors
      const colorScale = d3.scaleOrdinal(d3.schemeCategory10);
      const tooltip = d3.select("body").append("div").attr("class", "tooltip").style("display", "none");

      // Caches
      const pathCache = new Map();
      const searchCache = new Map();
      const communityCache = new Map();

      // Utilities
      function debounce(func, wait) {
        let timeout;
        return function(...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func(...args), wait);
        };
      }

      function throttle(func, limit) {
        let inThrottle;
        return function(...args) {
          if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
          }
        };
      }

      function autoFitNetwork() {
        if (!nodeGroups || nodeGroups.empty()) return;

        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;

        nodeGroups.each(function(d) {
          minX = Math.min(minX, d.x);
          maxX = Math.max(maxX, d.x);
          minY = Math.min(minY, d.y);
          maxY = Math.max(maxY, d.y);
        });

        const padding = 50;
        minX -= padding;
        maxX += padding;
        minY -= padding;
        maxY += padding;

        const networkWidth = maxX - minX;
        const networkHeight = maxY - minY;
        const scaleX = width / networkWidth;
        const scaleY = height / networkHeight;
        let scale = Math.max(0.1, Math.min(Math.min(scaleX, scaleY), 1.5));

        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        const transform = d3.zoomIdentity
          .translate(width / 2, height / 2)
          .scale(scale)
          .translate(-centerX, -centerY);

        svg.transition()
          .duration(1000)
          .call(zoom.transform, transform);
      }

      function init() {
        try {
          showLoadingIndicator();
          setupCanvas();
          loadData();
        } catch (err) {
          console.error('Init error:', err);
          updateLoadingStatus('Error: ' + err.message, 0);
        }
      }

      function showLoadingIndicator() {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
          overlay.style.display = 'flex';
          overlay.classList.remove('fade-out');
        }
      }

      function updateLoadingStatus(status, progress) {
        const statusEl = document.querySelector('.loading-status');
        const progressBar = document.getElementById('progress-bar');
        if (statusEl) statusEl.textContent = status;
        if (progressBar && progress !== undefined) progressBar.style.width = progress + '%';
      }

      function hideLoadingIndicator() {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
          overlay.classList.add('fade-out');
          setTimeout(() => overlay.style.display = 'none', 500);
        }
      }

      function setupCanvas() {
        svg = d3.select("#canvas");
        const rect = svg.node().getBoundingClientRect();
        width = rect.width || window.innerWidth;
        height = rect.height || window.innerHeight - 56;

        svg.attr("width", width).attr("height", height);

        zoom = d3.zoom()
          .scaleExtent([0.05, 10])
          .on("zoom", throttle((e) => {
            container.attr("transform", e.transform);
          }, 16));

        svg.call(zoom);
        container = svg.append("g");
      }

      async function loadData() {
        try {
          updateLoadingStatus('Loading network data...', 20);

          let data;
          // Try API first (when served from Flask editor), then fall back to static file
          const apiUrl = window.location.port === '5001'
            ? '/api/graph_magazines.json'
            : null;

          try {
            if (apiUrl) {
              data = await d3.json(apiUrl);
            } else {
              data = await d3.json("graph_magazines.json");
            }
          } catch (err) {
            // Fallback: try relative path
            const basePath = window.location.href.substring(0, window.location.href.lastIndexOf('/'));
            data = await d3.json(basePath + '/graph_magazines.json');
          }

          updateLoadingStatus('Processing relationships...', 40);
          processData(data);

          updateLoadingStatus('Computing layout...', 60);
          initializeSimulation(data);

          updateLoadingStatus('Rendering network...', 80);
          renderNetwork(data);

          updateLoadingStatus('Finalizing...', 90);
          setupEventHandlers();

          setTimeout(() => {
            initializeAutocomplete();
          }, 500);

          setTimeout(() => {
            updateLoadingStatus('Ready', 100);
            setTimeout(hideLoadingIndicator, 500);
          }, 4000);

        } catch (error) {
          console.error("Load error:", error);
          updateLoadingStatus('Failed to load: ' + error.message, 0);
          setTimeout(hideLoadingIndicator, 2000);
        }
      }

      function processData(data) {
        data.nodes.forEach((node, index) => {
          nodesById.set(node.id, node);
          nodesByIdLower.set(node.id.toLowerCase(), node);
          nodeIndexMap.set(node.id, index);
          adjacencyList.set(node.id, new Set());
          nodeDegrees.set(node.id, 0);
        });

        data.links.forEach(link => {
          const sourceId = typeof link.source === 'string' ? link.source : link.source.id;
          const targetId = typeof link.target === 'string' ? link.target : link.target.id;

          if (adjacencyList.has(sourceId) && adjacencyList.has(targetId)) {
            adjacencyList.get(sourceId).add(targetId);
            adjacencyList.get(targetId).add(sourceId);
            nodeDegrees.set(sourceId, nodeDegrees.get(sourceId) + 1);
            nodeDegrees.set(targetId, nodeDegrees.get(targetId) + 1);
          }
        });
      }

      function initializeSimulation(data) {
        const nodeCount = data.nodes.length;
        const angleStep = (2 * Math.PI) / nodeCount;
        const radius = Math.min(width, height) * 0.35;

        data.nodes.forEach((node, i) => {
          if (!node.x && !node.y) {
            const angle = i * angleStep;
            node.x = width / 2 + radius * Math.cos(angle) + (Math.random() - 0.5) * 20;
            node.y = height / 2 + radius * Math.sin(angle) + (Math.random() - 0.5) * 20;
          }
          node.vx = 0;
          node.vy = 0;
        });

        const baseForces = {
          linkDistance: 300,
          linkStrength: 0.15,
          chargeStrength: -2500,
          collisionRadius: 35
        };

        simulation = d3.forceSimulation(data.nodes)
          .force("link", d3.forceLink(data.links)
            .id(d => d.id)
            .distance(d => {
              const sourceDegree = nodeDegrees.get(d.source.id || d.source) || 1;
              const targetDegree = nodeDegrees.get(d.target.id || d.target) || 1;
              const avgDegree = (sourceDegree + targetDegree) / 2;
              return baseForces.linkDistance * (1 + Math.log(avgDegree) * 0.1);
            })
            .strength(baseForces.linkStrength))
          .force("charge", d3.forceManyBody()
            .strength(d => {
              const degree = nodeDegrees.get(d.id) || 1;
              return baseForces.chargeStrength * (1 + Math.log(degree) * 0.15);
            })
            .distanceMax(600)
            .theta(0.9))
          .force("center", d3.forceCenter(width / 2, height / 2).strength(0.02))
          .force("collision", d3.forceCollide()
            .radius(d => {
              const degree = nodeDegrees.get(d.id) || 1;
              return baseForces.collisionRadius + Math.min(degree * 0.5, 20);
            })
            .strength(0.7)
            .iterations(2))
          .velocityDecay(0.7)
          .alphaDecay(0.025)
          .alphaMin(0.001)
          .alpha(0.3);

        simulation.baseForces = baseForces;
        simulation.on("tick", onTick);

        setTimeout(() => {
          if (!isDragging) {
            simulation.stop();
            isSimulationActive = false;
            setTimeout(autoFitNetwork, 200);
          }
        }, 4500);
      }

      function onTick() {
        if (!renderRequestId) {
          renderRequestId = requestAnimationFrame(() => {
            updatePositions();
            renderRequestId = null;
          });
        }
      }

      function updatePositions() {
        if (nodeGroups) nodeGroups.attr("transform", d => `translate(${d.x}, ${d.y})`);
        if (linkElements) {
          linkElements
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);
        }
      }

      function renderNetwork(data) {
        linkElements = container.append("g")
          .attr("class", "links")
          .selectAll("line")
          .data(data.links)
          .join("line")
          .classed("link", true)
          .classed("personal", d => d.type === "personal");

        nodeGroups = container.append("g")
          .attr("class", "nodes")
          .selectAll("g.node")
          .data(data.nodes)
          .join("g")
          .classed("node", true)
          .call(createOptimizedDrag());

        nodeGroups.append("circle")
          .attr("r", d => {
            const degree = nodeDegrees.get(d.id) || 1;
            return 10 + Math.min(Math.sqrt(degree) * 3, 20);
          })
          .style("fill", d => d.type === 'institution' ? "#8b7355" : "#6b8e9f")
          .style("stroke", d => d.type === 'institution' ? "#6d5a44" : "#546f7d")
          .style("stroke-width", 2);

        labelElements = nodeGroups.append("text")
          .text(d => d.id)
          .attr("dx", d => {
            const degree = nodeDegrees.get(d.id) || 1;
            return 10 + Math.min(Math.sqrt(degree) * 3, 20) + 5;
          })
          .attr("dy", 5)
          .attr("class", "label")
          .style("opacity", labelsVisible ? 1 : 0)
          .style("font-size", "12px")
          .style("font-weight", d => (nodeDegrees.get(d.id) || 1) > 10 ? "600" : "400");

        nodeGroups
          .on("mouseenter", handleNodeMouseEnter)
          .on("mouseleave", handleNodeMouseLeave)
          .on("click", handleNodeClick);
      }

      function createOptimizedDrag() {
        return d3.drag()
          .on("start", (e, d) => {
            isDragging = true;
            d.fx = d.x;
            d.fy = d.y;
            if (!e.active && simulation.alpha() <= simulation.alphaMin()) {
              simulation.alphaTarget(0.01).restart();
              isSimulationActive = true;
            }
          })
          .on("drag", (e, d) => {
            d.fx = e.x;
            d.fy = e.y;
            d.x = e.x;
            d.y = e.y;

            if (nodeGroups) {
              nodeGroups.filter(n => n === d).attr("transform", `translate(${d.x}, ${d.y})`);
              if (linkElements) {
                linkElements.filter(l => l.source === d).attr("x1", d.x).attr("y1", d.y);
                linkElements.filter(l => l.target === d).attr("x2", d.x).attr("y2", d.y);
              }
            }
          })
          .on("end", (e, d) => {
            isDragging = false;
            if (!e.active) {
              simulation.alphaTarget(0);
              setTimeout(() => {
                if (!isDragging) {
                  simulation.stop();
                  isSimulationActive = false;
                }
              }, 200);
            }
            d.fx = null;
            d.fy = null;
          });
      }

      const handleNodeMouseEnter = throttle((e, d) => {
        const degree = nodeDegrees.get(d.id);
        tooltip.html(`<strong>${d.id}</strong><br>Connections: ${degree}`)
          .style("left", (e.pageX + 10) + "px")
          .style("top", (e.pageY - 10) + "px")
          .style("display", "block");
      }, 100);

      function handleNodeMouseLeave() {
        tooltip.style("display", "none");
      }

      function handleNodeClick(e, d) {
        e.stopPropagation();
        highlightNode(d);
      }

      function highlightNode(node) {
        const connectedNodes = new Set([node.id]);
        adjacencyList.get(node.id).forEach(id => connectedNodes.add(id));

        nodeGroups.style("opacity", d => connectedNodes.has(d.id) ? 1 : 0.1);
        linkElements.style("opacity", l => {
          const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
          const targetId = typeof l.target === 'object' ? l.target.id : l.target;
          return (connectedNodes.has(sourceId) || connectedNodes.has(targetId)) ? 1 : 0.1;
        });
      }

      function setupEventHandlers() {
        window.searchHandler = debounce(handleSearch, 300);

        const degreeRange = document.getElementById("degree-range");
        degreeRange.addEventListener("input", throttle(handleDegreeFilter, 50));
        handleDegreeFilter({ target: degreeRange });

        window.addEventListener("resize", debounce(handleResize, 250));
      }

      function handleSearch(e) {
        const term = e.target.value.trim().toLowerCase();
        if (!term) {
          resetView();
          return;
        }

        if (searchCache.has(term)) {
          const cached = searchCache.get(term);
          applySearchResults(cached.matched, cached.connected);
          return;
        }

        const regex = new RegExp(term, 'i');
        const matched = [];
        const connected = new Set();

        nodesById.forEach((node, id) => {
          if (regex.test(id)) {
            matched.push(node);
            adjacencyList.get(id).forEach(connId => connected.add(nodesById.get(connId)));
          }
        });

        searchCache.set(term, { matched, connected });
        if (searchCache.size > 50) {
          searchCache.delete(searchCache.keys().next().value);
        }

        applySearchResults(matched, connected);
      }

      function applySearchResults(matched, connected) {
        if (matched.length > 0) {
          const matchedSet = new Set(matched);
          const important = new Set([...matched, ...connected]);

          nodeGroups.style("opacity", d => important.has(d) ? 1 : 0.1);
          linkElements.style("opacity", l => {
            const source = typeof l.source === 'object' ? l.source : nodesById.get(l.source);
            const target = typeof l.target === 'object' ? l.target : nodesById.get(l.target);
            const sourceMatched = matchedSet.has(source);
            const targetMatched = matchedSet.has(target);
            const sourceImportant = important.has(source);
            const targetImportant = important.has(target);
            return ((sourceMatched && targetImportant) || (targetMatched && sourceImportant)) ? 1 : 0.1;
          });

          centerNodes(matched);
        }
      }

      function handleDegreeFilter(e) {
        const sliderValue = parseInt(e.target.value);
        const thresholds = [1, 5, 10, 30, 40, 50];
        const threshold = thresholds[sliderValue];

        document.getElementById("degree-label").textContent = threshold + "+";

        nodeGroups.style("opacity", d => (nodeDegrees.get(d.id) >= threshold) ? 1 : 0.1);
        linkElements.style("opacity", l => {
          const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
          const targetId = typeof l.target === 'object' ? l.target.id : l.target;
          return (nodeDegrees.get(sourceId) >= threshold || nodeDegrees.get(targetId) >= threshold) ? 0.6 : 0.1;
        });
      }

      function handleResize() {
        const rect = svg.node().getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        svg.attr("width", width).attr("height", height);

        if (simulation) {
          simulation.force("center", d3.forceCenter(width / 2, height / 2).strength(0.05));
          simulation.alpha(0.1).restart();
          setTimeout(() => { if (!isDragging) simulation.stop(); }, 500);
        }
      }

      function resetView() {
        nodeGroups.style("opacity", 1);
        linkElements.style("opacity", 0.3);
        autoFitNetwork();
        searchCache.clear();
      }

      function centerNodes(nodesToCenter) {
        if (!nodesToCenter || nodesToCenter.length === 0) return;

        const xExtent = d3.extent(nodesToCenter, d => d.x);
        const yExtent = d3.extent(nodesToCenter, d => d.y);
        const centerX = (xExtent[0] + xExtent[1]) / 2;
        const centerY = (yExtent[0] + yExtent[1]) / 2;

        let scale = 1;
        if (xExtent[1] - xExtent[0] > 0 && yExtent[1] - yExtent[0] > 0) {
          scale = Math.min(8, 0.9 / Math.max(
            (xExtent[1] - xExtent[0]) / width,
            (yExtent[1] - yExtent[0]) / height
          ));
        }
        if (nodesToCenter.length === 1) scale = Math.min(scale, 2);

        svg.transition()
          .duration(750)
          .call(zoom.transform, d3.zoomIdentity
            .translate(-centerX * scale + width / 2, -centerY * scale + height / 2)
            .scale(scale));
      }

      // Path finding
      function findPath() {
        const startInput = document.getElementById("start-node").value.trim();
        const endInput = document.getElementById("end-node").value.trim();

        if (!startInput || !endInput) {
          alert("Please select both a starting point and destination.");
          return;
        }

        const cacheKey = `${startInput.toLowerCase()}_${endInput.toLowerCase()}`;
        if (pathCache.has(cacheKey)) {
          const cached = pathCache.get(cacheKey);
          if (cached.nodes.size > 0) {
            highlightAllConnections(cached);
          } else {
            alert("No connection found between these nodes.");
          }
          return;
        }

        const result = findAllConnections(startInput.toLowerCase(), endInput.toLowerCase());
        pathCache.set(cacheKey, result);
        if (pathCache.size > 100) pathCache.delete(pathCache.keys().next().value);

        if (result.nodes.size > 0) {
          highlightAllConnections(result);
        } else {
          alert("No connections found between these nodes.");
        }
      }

      class MultiNodeConnectionFinder {
        constructor(allNodes, allLinks, adjacencyList) {
          this.allNodes = allNodes;
          this.allLinks = allLinks;
          this.adjacencyList = adjacencyList;
          this.nodesByIdLower = new Map();
          allNodes.forEach(node => this.nodesByIdLower.set(node.id.toLowerCase(), node));
        }

        findMultiNodeConnections(selectedNodeIds) {
          const normalizedIds = selectedNodeIds.map(id => id.toLowerCase());
          const validNodes = normalizedIds.filter(id => this.nodesByIdLower.has(id));

          if (validNodes.length === 0) return { nodes: new Set(), edges: new Set() };
          if (validNodes.length === 1) return this.findSingleNodeNeighborhood(validNodes[0]);
          if (validNodes.length === 2) return this.findTwoNodePaths(validNodes[0], validNodes[1]);
          return this.findSteinerTree(validNodes);
        }

        findSingleNodeNeighborhood(nodeId) {
          const node = this.nodesByIdLower.get(nodeId);
          const connectedNodes = new Set([node.id]);
          const connectedEdges = new Set();

          const neighbors = this.adjacencyList.get(node.id) || new Set();
          neighbors.forEach(neighbor => {
            connectedNodes.add(neighbor);
            connectedEdges.add([node.id, neighbor].sort().join('--'));
          });

          return { nodes: connectedNodes, edges: connectedEdges };
        }

        findTwoNodePaths(startId, endId) {
          const startNode = this.nodesByIdLower.get(startId);
          const endNode = this.nodesByIdLower.get(endId);

          if (startNode.id === endNode.id) return this.findSingleNodeNeighborhood(startId);

          const connectedNodes = new Set();
          const connectedEdges = new Set();
          const shortestLength = this.bfsShortestPath(startNode.id, endNode.id);

          if (shortestLength === -1) return { nodes: new Set(), edges: new Set() };

          const maxPathLength = 4;
          const pathLengthTolerance = 1;
          const paths = this.findAllPathsBFS(startNode.id, endNode.id, Math.min(maxPathLength, shortestLength + pathLengthTolerance));

          paths.forEach(path => {
            path.forEach(nodeId => connectedNodes.add(nodeId));
            for (let i = 0; i < path.length - 1; i++) {
              connectedEdges.add([path[i], path[i + 1]].sort().join('--'));
            }
          });

          this.addCommonNeighbors(startNode.id, endNode.id, connectedNodes, connectedEdges);
          return { nodes: connectedNodes, edges: connectedEdges };
        }

        findSteinerTree(terminalNodeIds) {
          const connectedNodes = new Set();
          const connectedEdges = new Set();
          const terminals = terminalNodeIds.map(id => this.nodesByIdLower.get(id).id);
          const maxPathLength = 4;
          const pathLengthTolerance = 1;
          const allPairPaths = new Map();
          const shortestDistances = new Map();

          for (let i = 0; i < terminals.length; i++) {
            for (let j = i + 1; j < terminals.length; j++) {
              const source = terminals[i];
              const target = terminals[j];
              const key = [source, target].sort().join('--');
              const shortestDist = this.bfsShortestPath(source, target);

              if (shortestDist !== -1) {
                shortestDistances.set(key, shortestDist);
                const maxLength = Math.min(maxPathLength, shortestDist + pathLengthTolerance);
                const paths = this.findAllPathsBFS(source, target, maxLength);
                if (paths.length > 0) allPairPaths.set(key, paths);
              }
            }
          }

          const mstEdges = this.primMST(terminals, shortestDistances);

          mstEdges.forEach(([source, target]) => {
            const key = [source, target].sort().join('--');
            const paths = allPairPaths.get(key);
            if (paths) {
              paths.forEach(path => {
                path.forEach(nodeId => connectedNodes.add(nodeId));
                for (let i = 0; i < path.length - 1; i++) {
                  connectedEdges.add([path[i], path[i + 1]].sort().join('--'));
                }
              });
            }
          });

          for (let i = 0; i < terminals.length; i++) {
            for (let j = i + 1; j < terminals.length; j++) {
              const source = terminals[i];
              const target = terminals[j];
              const neighbors = this.adjacencyList.get(source);
              if (neighbors && neighbors.has(target)) {
                connectedNodes.add(source);
                connectedNodes.add(target);
                connectedEdges.add([source, target].sort().join('--'));
              }
              this.addCommonNeighbors(source, target, connectedNodes, connectedEdges);
            }
          }

          return { nodes: connectedNodes, edges: connectedEdges };
        }

        bfsShortestPath(start, end) {
          const queue = [[start, 0]];
          const visited = new Set();

          while (queue.length > 0) {
            const [node, distance] = queue.shift();
            if (node === end) return distance;
            if (visited.has(node)) continue;
            visited.add(node);

            const neighbors = this.adjacencyList.get(node);
            if (neighbors) {
              neighbors.forEach(neighbor => {
                if (!visited.has(neighbor)) queue.push([neighbor, distance + 1]);
              });
            }
          }
          return -1;
        }

        findAllPathsBFS(start, end, maxLength) {
          const allPaths = [];
          const queue = [[start]];

          while (queue.length > 0) {
            const path = queue.shift();
            const currentNode = path[path.length - 1];

            if (path.length > maxLength + 1) continue;
            if (currentNode === end) {
              allPaths.push([...path]);
              continue;
            }

            const neighbors = this.adjacencyList.get(currentNode);
            if (neighbors) {
              neighbors.forEach(neighbor => {
                if (!path.includes(neighbor)) queue.push([...path, neighbor]);
              });
            }
          }
          return allPaths;
        }

        addCommonNeighbors(startId, endId, connectedNodes, connectedEdges) {
          const startNeighbors = this.adjacencyList.get(startId) || new Set();
          const endNeighbors = this.adjacencyList.get(endId) || new Set();

          startNeighbors.forEach(neighbor => {
            if (endNeighbors.has(neighbor)) {
              connectedNodes.add(neighbor);
              connectedNodes.add(startId);
              connectedNodes.add(endId);
              connectedEdges.add([startId, neighbor].sort().join('--'));
              connectedEdges.add([endId, neighbor].sort().join('--'));
            }
          });
        }

        primMST(nodes, distances) {
          if (nodes.length === 0) return [];
          const mstEdges = [];
          const inMST = new Set([nodes[0]]);

          while (inMST.size < nodes.length) {
            let minEdge = null;
            let minDistance = Infinity;

            inMST.forEach(u => {
              nodes.forEach(v => {
                if (!inMST.has(v)) {
                  const key = [u, v].sort().join('--');
                  const dist = distances.get(key);
                  if (dist !== undefined && dist < minDistance) {
                    minDistance = dist;
                    minEdge = [u, v];
                  }
                }
              });
            });

            if (minEdge) {
              mstEdges.push(minEdge);
              inMST.add(minEdge[1]);
            } else break;
          }
          return mstEdges;
        }
      }

      function findAllConnections(startId, endId) {
        const finder = new MultiNodeConnectionFinder(
          Array.from(nodesById.values()),
          linkElements ? linkElements.data() : [],
          adjacencyList
        );

        const result = finder.findTwoNodePaths(startId.toLowerCase(), endId.toLowerCase());
        const startNode = nodesByIdLower.get(startId.toLowerCase());
        const endNode = nodesByIdLower.get(endId.toLowerCase());

        if (!startNode || !endNode) {
          return { nodes: new Set(), edges: new Set(), startNode: null, endNode: null, shortestPathLength: -1, pathCount: 0, pathsByLength: new Map() };
        }

        const shortestLength = finder.bfsShortestPath(startNode.id, endNode.id);
        const pathsByLength = new Map();
        let totalPaths = 0;

        if (shortestLength !== -1) {
          const maxPathLength = 4;
          const tolerance = 1;
          for (let length = shortestLength; length <= Math.min(maxPathLength, shortestLength + tolerance); length++) {
            const pathsAtLength = finder.findAllPathsBFS(startNode.id, endNode.id, length)
              .filter(path => path.length - 1 === length);
            if (pathsAtLength.length > 0) {
              pathsByLength.set(length, pathsAtLength.length);
              totalPaths += pathsAtLength.length;
            }
          }
        }

        const startNeighbors = adjacencyList.get(startNode.id) || new Set();
        const endNeighbors = adjacencyList.get(endNode.id) || new Set();
        const commonNeighbors = Array.from(startNeighbors).filter(n => endNeighbors.has(n));

        return {
          nodes: result.nodes || new Set(),
          edges: result.edges || new Set(),
          startNode: startNode.id,
          endNode: endNode.id,
          shortestPathLength: shortestLength,
          pathCount: totalPaths,
          pathsByLength,
          commonNeighbors: commonNeighbors.length
        };
      }

      function highlightAllConnections(result) {
        clearPath();

        const { nodes: connectedNodes, edges: connectedEdges, startNode, endNode, shortestPathLength, pathCount, pathsByLength, commonNeighbors } = result;

        const pathInfoEl = document.getElementById('path-info');
        if (shortestPathLength !== undefined && pathInfoEl) {
          let infoText = '';
          if (shortestPathLength === -1) {
            infoText = 'No connection found between these nodes';
          } else if (shortestPathLength === 1) {
            infoText = 'Direct relationship identified';
            if (pathCount > 1 && pathsByLength) {
              const additionalPaths = pathCount - (pathsByLength.get(1) || 1);
              if (additionalPaths > 0) infoText += ` + ${additionalPaths} alternative path${additionalPaths > 1 ? 's' : ''}`;
            }
          } else {
            infoText = `${shortestPathLength} degrees of separation`;
            if (pathsByLength && pathsByLength.size > 0) {
              const pathDetails = [];
              pathsByLength.forEach((count, length) => {
                if (count > 0) pathDetails.push(`${count} path${count > 1 ? 's' : ''} at ${length}`);
              });
              if (pathDetails.length > 0) infoText += ` (${pathDetails.join(', ')})`;
            }
          }
          if ((commonNeighbors || 0) > 0) infoText += ` | ${commonNeighbors} shared contact${commonNeighbors > 1 ? 's' : ''}`;

          pathInfoEl.innerHTML = infoText;
          pathInfoEl.style.display = 'block';
        }

        nodeGroups.style("opacity", d => connectedNodes.has(d.id) ? 1 : 0)
          .style("display", d => connectedNodes.has(d.id) ? "block" : "none");

        linkElements.style("opacity", function(l) {
          const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
          const targetId = typeof l.target === 'object' ? l.target.id : l.target;
          return connectedEdges.has([sourceId, targetId].sort().join('--')) ? 1 : 0;
        }).style("display", function(l) {
          const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
          const targetId = typeof l.target === 'object' ? l.target.id : l.target;
          return connectedEdges.has([sourceId, targetId].sort().join('--')) ? "block" : "none";
        });

        linkElements.each(function(l) {
          const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
          const targetId = typeof l.target === 'object' ? l.target.id : l.target;
          if (connectedEdges.has([sourceId, targetId].sort().join('--'))) {
            d3.select(this).classed("highlight-path", true);
          }
        });

        nodeGroups.select("circle").each(function(d) {
          if (connectedNodes.has(d.id)) {
            const isEndpoint = (d.id === startNode || d.id === endNode);
            d3.select(this)
              .classed("highlight-node", true)
              .style("stroke", isEndpoint ? "#c4a35a" : "#a08a6e")
              .style("stroke-width", isEndpoint ? "4px" : "3px")
              .style("fill", function() {
                if (d.id === startNode) return "#4a7c59";
                if (d.id === endNode) return "#8b3a3a";
                return d.type === 'institution' ? "#8b7355" : "#6b8e9f";
              });
          }
        });

        labelElements.style("opacity", d => connectedNodes.has(d.id) ? 1 : 0)
          .style("display", d => connectedNodes.has(d.id) ? "block" : "none");

        centerNodes(Array.from(connectedNodes).map(id => nodesById.get(id)));
      }

      function clearPath() {
        const pathInfoEl = document.getElementById('path-info');
        if (pathInfoEl) pathInfoEl.style.display = 'none';

        nodeGroups.style("opacity", 1).style("display", "block");
        nodeGroups.select("circle")
          .classed("highlight-node", false)
          .style("stroke", d => d.type === 'institution' ? "#6d5a44" : "#546f7d")
          .style("stroke-width", 2)
          .style("fill", d => d.type === 'institution' ? "#8b7355" : "#6b8e9f");

        linkElements
          .classed("highlight-path", false)
          .style("opacity", 0.4)
          .style("display", "block");

        labelElements
          .style("opacity", labelsVisible ? 1 : 0)
          .style("display", labelsVisible ? "block" : "none");
      }

      async function exportPNG() {
        try {
          const clonedSvg = svg.node().cloneNode(true);
          const svgNS = "http://www.w3.org/2000/svg";

          const styleEl = document.createElementNS(svgNS, "style");
          styleEl.innerHTML = `
            .link { stroke: #c4b5a0; stroke-opacity: 0.4; stroke-width: 1.5; }
            .link.personal { stroke: #b07070; }
            .highlight-path { stroke: #c4a35a; stroke-width: 3px; stroke-opacity: 0.9; }
            .label { font-size: 12px; font-family: Georgia, serif; fill: #3d3d3d; }
          `;
          clonedSvg.insertBefore(styleEl, clonedSvg.firstChild);

          const bbox = container.node().getBBox();
          const rect = document.createElementNS(svgNS, "rect");
          rect.setAttribute("x", bbox.x - 50);
          rect.setAttribute("y", bbox.y - 50);
          rect.setAttribute("width", bbox.width + 100);
          rect.setAttribute("height", bbox.height + 100);
          rect.setAttribute("fill", "#f7f4ed");
          clonedSvg.insertBefore(rect, clonedSvg.firstChild);

          const svgString = new XMLSerializer().serializeToString(clonedSvg);
          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');

          await canvg.Canvg.fromString(ctx, svgString).render();

          const a = document.createElement('a');
          a.download = 'italian-american-literary-network.png';
          a.href = canvas.toDataURL();
          a.click();
        } catch (error) {
          console.error("Export error:", error);
          alert("Unable to export image. Please try again.");
        }
      }

      function fullReset() {
        clearPath();
        resetView();

        nodeGroups.select("circle")
          .style("fill", d => d.type === 'institution' ? "#8b7355" : "#6b8e9f")
          .style("stroke", d => d.type === 'institution' ? "#6d5a44" : "#546f7d")
          .style("stroke-width", 2)
          .classed("highlight-node", false);

        linkElements.classed("highlight-path", false).style("opacity", 0.4);

        document.getElementById("search").value = "";
        document.getElementById("start-node").value = "";
        document.getElementById("end-node").value = "";
        document.getElementById("degree-range").value = "0";
        document.getElementById("degree-label").textContent = "1+";

        searchCache.clear();
        pathCache.clear();
      }

      function initializeAutocomplete() {
        if (nodesById.size === 0) return;

        const names = Array.from(nodesById.keys()).sort();
        ['search', 'start-node', 'end-node'].forEach(id => {
          const input = document.getElementById(id);
          if (input) {
            const existing = document.getElementById(id + 'autocomplete-list');
            if (existing) existing.remove();
            const newInput = input.cloneNode(true);
            input.parentNode.replaceChild(newInput, input);
          }
        });

        setTimeout(() => {
          const searchInput = document.getElementById("search");
          const startInput = document.getElementById("start-node");
          const endInput = document.getElementById("end-node");

          if (searchInput) {
            createOptimizedAutocomplete(searchInput, names);
            searchInput.addEventListener("input", window.searchHandler);
          }
          if (startInput) createOptimizedAutocomplete(startInput, names);
          if (endInput) createOptimizedAutocomplete(endInput, names);
        }, 100);
      }

      function createOptimizedAutocomplete(input, items) {
        if (!input || !items || items.length === 0) return;

        let currentFocus = -1;
        const searchIndex = items.map(item => ({ original: item, lower: item.toLowerCase() }));

        const handleAutocomplete = function() {
          const val = this.value.trim().toLowerCase();
          closeAllLists();
          if (!val || val.length < 1) return;

          currentFocus = -1;
          const autocompleteList = document.createElement("DIV");
          autocompleteList.setAttribute("id", this.id + "autocomplete-list");
          autocompleteList.setAttribute("class", "autocomplete-items");
          if (!this.parentNode.style.position || this.parentNode.style.position === 'static') {
            this.parentNode.style.position = 'relative';
          }
          this.parentNode.appendChild(autocompleteList);

          let matchCount = 0;
          const maxMatches = 15;
          const matches = [];

          for (let i = 0; i < searchIndex.length && matchCount < maxMatches; i++) {
            if (searchIndex[i].lower.startsWith(val)) {
              matches.push({ item: searchIndex[i], priority: 1 });
              matchCount++;
            }
          }

          if (matchCount < maxMatches) {
            for (let i = 0; i < searchIndex.length && matchCount < maxMatches; i++) {
              if (!searchIndex[i].lower.startsWith(val) && searchIndex[i].lower.includes(val)) {
                matches.push({ item: searchIndex[i], priority: 2 });
                matchCount++;
              }
            }
          }

          matches.sort((a, b) => a.priority - b.priority);

          matches.forEach(match => {
            const searchItem = match.item;
            if (searchItem.lower.includes(val)) {
              const item = searchItem.original;
              const matchIndex = searchItem.lower.indexOf(val);
              const itemDiv = document.createElement("DIV");
              const strongEl = document.createElement('strong');
              strongEl.textContent = item.substr(matchIndex, val.length);

              itemDiv.textContent = item.substr(0, matchIndex);
              itemDiv.appendChild(strongEl);
              itemDiv.appendChild(document.createTextNode(item.substr(matchIndex + val.length)));
              itemDiv.dataset.value = item;

              itemDiv.addEventListener("click", function() {
                input.value = this.dataset.value;
                closeAllLists();
                input.dispatchEvent(new Event('input', { bubbles: true }));
              });

              autocompleteList.appendChild(itemDiv);
            }
          });
        };

        input.addEventListener("input", handleAutocomplete);
        input.addEventListener("focus", function(e) {
          if (this.value.length >= 1) handleAutocomplete.call(this, e);
        });

        input.addEventListener("keydown", function(e) {
          let items = document.getElementById(this.id + "autocomplete-list");
          if (items) items = items.getElementsByTagName("div");

          if (e.keyCode === 40) {
            currentFocus++;
            addActive(items);
          } else if (e.keyCode === 38) {
            currentFocus--;
            addActive(items);
          } else if (e.keyCode === 13) {
            e.preventDefault();
            if (currentFocus > -1 && items) items[currentFocus].click();
          } else if (e.keyCode === 27) {
            closeAllLists();
          }
        });

        function addActive(items) {
          if (!items) return;
          removeActive(items);
          if (currentFocus >= items.length) currentFocus = 0;
          if (currentFocus < 0) currentFocus = items.length - 1;
          items[currentFocus].classList.add("autocomplete-active");
        }

        function removeActive(items) {
          for (let i = 0; i < items.length; i++) items[i].classList.remove("autocomplete-active");
        }

        function closeAllLists(elmnt) {
          const items = document.getElementsByClassName("autocomplete-items");
          for (let i = items.length - 1; i >= 0; i--) {
            if (elmnt != items[i] && elmnt != input) items[i].parentNode.removeChild(items[i]);
          }
        }

        document.addEventListener("click", e => closeAllLists(e.target));
        input.addEventListener("blur", () => setTimeout(() => closeAllLists(), 200));
      }

      return {
        init,
        findPath,
        clearPath,
        exportPNG,
        fullReset,
        autoFit: autoFitNetwork
      };
    })();

    // Global functions
    function toggleSidebar() {
      document.getElementById("sidebar").classList.toggle("hidden");
    }

    function openAboutModal() {
      const modal = document.getElementById('aboutModal');
      modal.classList.remove('closing');
      modal.classList.add('show');
    }

    function closeAboutModal() {
      const modal = document.getElementById('aboutModal');
      modal.classList.add('closing');
      setTimeout(() => modal.classList.remove('show', 'closing'), 300);
    }

    // Initialize
    document.addEventListener("DOMContentLoaded", function() {
      if (typeof NetworkViz !== 'undefined' && !window.vizInitialized) {
        window.vizInitialized = true;
        NetworkViz.init();
      }

      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
          const modal = document.getElementById('aboutModal');
          if (modal && modal.classList.contains('show')) closeAboutModal();
        }
      });
    });

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      setTimeout(() => {
        if (typeof NetworkViz !== 'undefined' && !window.vizInitialized) {
          window.vizInitialized = true;
          NetworkViz.init();
        }
      }, 100);
    }
  </script>
</body>
</html>
